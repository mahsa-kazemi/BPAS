#include "RationalNumberPolynomial/mrpolynomial-altarr.hpp"

////////// Construtors ////////////////////////////////////

/**
 * Private constructor to create SMQP directly from a Node*.
 * Makes a copy of input varNames
 */
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial(AltArr_t* aa, int vars, Symbol* varNames) : 
    poly(aa),
    nvar(vars) 
{
    names = new Symbol[nvar+1];
    std::copy(varNames, varNames+nvar+1, names);
}

/**
 * Construct a multivariate polynomial
 *
 **/
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial() : 
    poly(NULL),
    nvar(0)
{
    names = new Symbol[1];
    names[0] = "1";
}

/**
 * Construct a multivariate polynomial with specific number of variables
 *
 * @param v: Number of variables
 **/
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial(int v) :
    poly(NULL),
    nvar(v)
{
    names = new Symbol[nvar+1];
    names[0] = "1";
    for (int i = 1; i <= nvar; ++i) {
        std::ostringstream convert;
        convert << i;
        names[i] = "x_";
        names[i] += convert.str();
    }
}

/**
 * Construct with a variable name such that f(x) = x;
 *
 * @param x: The variable name
 **/
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial (const Symbol& x) :
    poly(NULL),
    nvar(1)
{
    names = new Symbol[2];
    names[0] = "9";
    names[1] = x;

    mpq_t coef;
    mpq_init(coef);
    mpq_set_ui(coef, 1ul, 1ul);
    poly = makeConstPolynomial_AA(1, nvar, coef);
    degree_t degsList[nvar] = {0};
    degsList[0] = 1;
    setDegrees_AA_inp(poly, 0, degsList, 1); 
    // poly->elems->degs = 1;
    mpq_clear(coef);
}

SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial (const std::string& str) :
poly(NULL), 
nvar(0),
names(NULL)
{
    this->fromString(str);
}


/**
 * Copy Constructor.
 * 
 * Does not reuse underlying memory allocated by b. 
 *
 * @param b: A sparse multivariate polynomial
 **/
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial(const SparseMultivariateRationalPolynomial& b) :
    nvar(b.nvar)
{
    poly = deepCopyPolynomial_AA(b.poly);
    names = new Symbol[nvar+1];
    std::copy(b.names, b.names+nvar+1, names);
    slp = std::vector<SLPRepresentation>(b.slp);
}

/**
 * Move Constructor.
 *
 * @params b: The r-value reference polynomial.
 */
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial(SparseMultivariateRationalPolynomial&& b) {
    nvar = b.nvar;
    poly = b.poly;
    names = b.names;
    names = new Symbol[nvar+1];
    std::copy(b.names, b.names+nvar+1, names);
    slp = b.slp;

    b.poly = NULL;
    b.slp.clear();
}


/**
 * Create an SMZP from a SMQP.
 */
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial(const SparseMultivariateIntegerPolynomial& b) {
    nvar = b.nvar;
    poly = deepCopyPolynomial_AAFromAAZ(b.poly);
    names = new Symbol[nvar+1];
    std::copy(b.names, b.names+nvar+1, names);
}

/**
 * Create a SMQP from a Integer. 
 */
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial(const Integer& r, int nv) :
    nvar(nv),
    poly(NULL)
{   
    mpq_t coef;
    mpq_init(coef);
    mpz_set(mpq_numref(coef), r.get_mpz_t());
    poly = makeConstPolynomial_AA(1, nvar, coef);
    mpq_clear(coef);

    names = new Symbol[nvar+1];
    names[0] = "1";
    for (int i = 1; i <= nvar; ++i) {
        std::ostringstream convert;
        convert << i;
        names[i] = "x_";
        names[i] += convert.str();
    }
}

/**
 * Create a SMQP from a RationalNumber. 
 */
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial(const RationalNumber& r, int nv) :
    nvar(nv),
    poly(NULL)
{
    poly = makeConstPolynomial_AA(1, nvar, r.get_mpq_t());

    names = new Symbol[nvar+1];
    names[0] = "1";
    for (int i = 1; i <= nvar; ++i) {
        std::ostringstream convert;
        convert << i;
        names[i] = "x_";
        names[i] += convert.str();
    }

}

/**
 * Create a SMQP from a univariate rational polynomial. 
 * 
 * @param p: A SUQP polynomial. 
 **/
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial (const DenseUnivariateRationalPolynomial& p) : 
    nvar(1),
    poly(NULL) 
{
    names = new Symbol[nvar+1];
    names[0] = "9";
    names[1] = p.variable();

    RationalNumber coef;
    long int pDeg = p.degree().get_si();
    poly = makePolynomial_AA(pDeg+1, nvar);
    int curSize = 0;
    degree_t degsList[nvar] = {0};
    for (long int i = pDeg; i >= 0; --i) {
        coef = p.coefficient(i);
        if (coef != 0) {
            mpq_init(poly->elems[curSize].coef);
            mpq_set(poly->elems[curSize].coef, coef.get_mpq_t());
            degsList[0] = i;
            setDegrees_AA_inp(poly, curSize, degsList, nvar);
            // poly->elems[curSize].degs = i;
            ++curSize;
        }
    }
    poly->size = curSize;
}

/**
 * Construct from a SUP<SMQP> polynomial
 *
 * @param s: The SUP<SMQP> polynomial
 **/
SparseMultivariateRationalPolynomial::SparseMultivariateRationalPolynomial (const SparseUnivariatePolynomial<SparseMultivariateRationalPolynomial>& s) :
    nvar(0),
    poly(NULL)
{
    names = new Symbol[1];
    names[0] = "1";

    long long int d = s.degree().get_si();
    SparseMultivariateRationalPolynomial c = s.coefficient(d);
    while (c.isZero()) {
        --d;
        if (d < 0) {
            return;
        }
        c = s.coefficient(d);
    }
    if (c.nvar == 0) {
        //then we have a bunch of "constant" SMQP's as coefficients in SUP.
        delete[] names;
        names = new Symbol[2];
        names[0] = "9";
        names[1] = s.variable();
        nvar = 1;

        poly = makePolynomial_AA(d+1, nvar);
        int curSize = 0;
        degree_t degsList[nvar] = {0};
        for (int k = d; k >= 0; --k) {
            SparseMultivariateRationalPolynomial coef = s.coefficient(k);
            if (coef.isZero()) {
                continue;
            }
            mpq_init(poly->elems[curSize].coef);
            mpq_set(poly->elems[curSize].coef, coef.poly->elems[0].coef);
            degsList[0] = k;
            setDegrees_AA_inp(poly, curSize, degsList, nvar);
            // poly->elems[curSize].degs = k;
            ++curSize;
        }
        poly->size = curSize;

        return;
    }

    nvar = c.nvar + 1;
    AltArr_t* newPoly = makePolynomial_AA(1, nvar);
    delete[] names;
    names = new Symbol[nvar+1];
    names[0] = "9";
    names[1] = s.variable();
    std::copy(c.names+1, c.names+1+c.nvar, names+2);

    int mvarDegOffset = getMVarExpOffset(nvar);
    for (int k = 0; k <= d; ++k) {
        c = s.coefficient(k);
        //coefficient is 0 so do nothing
        if (c.isZero()) {
            continue;
        }

        //Get the coef poly, expanding it's num vars and multiply through
        //by x^k.
        expandNumVarsLeft_AA(c.poly, nvar);
        c.poly = mainLShiftPolynomial_AA_inp(c.poly, k);
        // for (int i = 0; i < c.poly->size; ++i) {
        //     c.poly->elems[i].degs |= ((degrees_t) k << mvarDegOffset);
        // }
        newPoly = addPolynomials_AA_inp(newPoly, c.poly, nvar);
    }

    this->poly = newPoly;
}

/**
 * Destroy the polynomial and release underlying node memory.
 **/
SparseMultivariateRationalPolynomial::~SparseMultivariateRationalPolynomial() {
    delete[] names;
    freePolynomial_AA(poly);
    slp.clear();
}



////////// BPASRing /////////////////////////////////

bool SparseMultivariateRationalPolynomial::isZero() const {
    return isZero_AA(poly);
}

void SparseMultivariateRationalPolynomial::zero() {
    freePolynomial_AA(poly);
    poly = NULL;
}

bool SparseMultivariateRationalPolynomial::isOne() const {
    return isOne_AA(poly);
}

void SparseMultivariateRationalPolynomial::one() {
    freePolynomial_AA(poly);
    RationalNumber r(1);
    poly = makeConstPolynomial_AA(1, nvar, r.get_mpq_t());
}

bool SparseMultivariateRationalPolynomial::isNegativeOne() const {
    return isNegativeOne_AA(poly);
}

void SparseMultivariateRationalPolynomial::negativeOne() {
    freePolynomial_AA(poly);
    RationalNumber r(-1);
    poly = makeConstPolynomial_AA(1, nvar, r.get_mpq_t());
}

int SparseMultivariateRationalPolynomial::isConstant() const {
    return isConstant_AA(poly);
}

/**
 * Subresultant Chain
 * Return the list of subresultants
 *
 * @param q: The other sparse univariate polynomial
 **/
std::vector<SparseMultivariateRationalPolynomial> SparseMultivariateRationalPolynomial::subresultantChain (const SparseMultivariateRationalPolynomial& q, int filled) const {

    bool TYPE = 0; // 0: SMZP Ducos Algorithm, 1: SUP Ducos Algorothm
    Symbol v = q.leadingVariable();
    if (v != leadingVariable()) {
        std::cout << "BPAS: error, cannot compute subresultant chain if leading variable of input is different from leading variable of the current object." << std::endl;
        exit(1);
    }

    if (TYPE == 0){
    // // Subresultant from SMZP:
        std::vector<int> xs;
        bool isOrdered = isOrderedRing(q, xs);
        SparseMultivariateRationalPolynomial ppP, ppQ;
        std::vector<SparseMultivariateRationalPolynomial> subr;

        if (!isOrdered) {
            std::cout << "BPAS: error, trying to compute subresultant chain between Q[";
            for (int i = 1; i <= nvar; ++i) {
                std::cout << names[i];
                if (i < nvar) { std::cout << ", "; }
            }
            std::cout << "] and Q[";
            for (int i = 1; i <= q.nvar; ++i) {
                std::cout << q.names[i];
                if (i < q.nvar) { std::cout << ", "; }
            }
            std::cout << "]." << std::endl;
            exit(1);
        }

        int superNvar = xs.size() / 2;
        if (superNvar != nvar || superNvar != q.nvar) {

    //map indices to the expanded superset. 
            int varmap[nvar];
            int qvarmap[q.nvar];
            for (int i = 0; i < xs.size(); i += 2) {
                if (xs[i] != 0) {
                    varmap[xs[i]-1] = i/2;
                }
                if (xs[i+1] != 0) {
                    qvarmap[xs[i+1]-1] = i/2;
                }
            }

    //create new combined names array
            Symbol newnames[superNvar+1];
    //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
            newnames[0] = this->names[0];
            for (int i = 0; i < xs.size(); i += 2) {
                if (xs[i] != 0) {
                    newnames[(i/2) + 1] = names[xs[i]];
                } else {
                    newnames[(i/2) + 1] = q.names[xs[i+1]];
                }
            }

            ppP = this->expandVariables(superNvar, newnames, varmap);
            ppQ = q.expandVariables(superNvar, newnames, qvarmap);
    // ppP = ppP.primitivePart();
    // ppQ = ppQ.primitivePart();
        } else {
            ppP = *this;
            ppQ = q;

    // ppP = this->primitivePart();
    // ppQ = q.primitivePart();
        }    

        AltArr_t* Pq = primitivePart_AA (ppP.poly);
        AltArr_t* Qq = primitivePart_AA (ppQ.poly);
        unpackExponentVectors_AA_inp(Pq);
        unpackExponentVectors_AA_inp(Qq);

    // AltArrZ_t* P = deepCopyPolynomial_AAZFromAA (Pq);
    // AltArrZ_t* Q = deepCopyPolynomial_AAZFromAA (Qq);

    // freePolynomial_AA (Pq);
    // freePolynomial_AA (Qq);

        std::cout << "\n\n\n\n";
        std::cout << "ppP := " << ppP << std::endl;
        std::cout << "ppQ := " << ppQ << std::endl;


    // AltArrZ_t* P = deepCopyPolynomial_AAZFromAA (ppP.poly);
    // AltArrZ_t* Q = deepCopyPolynomial_AAZFromAA (ppQ.poly);

    int lvarP = leadingVariable_AA(Pq);//leadingVariable_AAZ (P);
    int lvarQ =  leadingVariable_AA(Qq);//leadingVariable_AAZ (Q);
    bool isShrinked = 0;

    if (lvarP != lvarQ){
        std::cout << "BPAS Error: cannot compute subresultant chain if leading variable of input is different from leading variable of the current object." << std::endl;
        exit(1);
    }

    if (lvarP > 0){
        for (int i = 0; i < lvarP; ++i){
            shrinkNumVarsAtIdx_AA (Pq, 0);
    // shrinkNumVarsAtIdx_AAZ (P, 0);
            shrinkNumVarsAtIdx_AA (Qq, 0);
    // shrinkNumVarsAtIdx_AAZ (Q, 0);
        }
        isShrinked = 1;
    }

    // if (leadingVariable_AAZ (P) != 0 || leadingVariable_AAZ (Q) != 0){
    //     std::cout << "BPAS Error: shrink in subresultantChain does not work properly!" << std::endl;
    //     exit(1);
    // }

    AltArrs_t* SC;
    // AltArrsZ_t* SC;
    AltArr_t* tmp;
    int size = 0;
    DucosSubresultantChain (Pq,Qq, &SC, &size);
    // DucosSubresultantChainZ (P,Q, &SC, &size);

    freePolynomial_AA (Pq); // free
    // freePolynomial_AAZ (P); // free
    freePolynomial_AA (Qq); // free
    // freePolynomial_AAZ (Q); // free

    AltArrs_t* cur = SC;
    // AltArrsZ_t* cur = SC;
    subr.reserve (size);
    // cerr << "size := " << size << std::endl;                        // TEST

    for (int i = 0; cur != NULL && i < size; ++i){
    tmp = cur->poly;//deepCopyPolynomial_AAFromAAZ (cur->poly);
    if (isShrinked && tmp != NULL && tmp->size != 0){
        expandNumVarsLeft_AA (tmp, ppP.nvar);
        if (tmp->nvar != ppP.nvar){
            std::cout << "BPAS Error: expand in subresultantChain does not work properly!" << std::endl;
            exit(1);
        }
    }
    SparseMultivariateRationalPolynomial tmpSMQP(tmp, ppP.nvar, ppP.names);
    std::cerr << "tmpSMQP:  " << tmpSMQP << std::endl;
    tmpSMQP.poly = NULL;
    tryPackExponentVectors_AA_inp(tmp);
    subr.push_back (SparseMultivariateRationalPolynomial (tmp, ppP.nvar, ppP.names));

    cur = cur->next;
    }

    // freeAltArrsZ (SC); // free

    if (filled && subr.size() > 1){

    // std::cout << "[Ali-TEST] In SMQP, subr.size =  " << subr.size() << std::endl;

        std::vector<SparseMultivariateRationalPolynomial> chain = subr;
        SparseMultivariateRationalPolynomial zero;
        zero.zero();

    // std::cout << "[Ali-TEST] In SMQP, poly =  " << chain[chain.size()-2] << std::endl;

        degree_t fullSize = mainLeadingDegree_AA (chain[chain.size()-2].poly) + 2;
        degree_t delta;

    // std::cerr << "chain.size() = " << chain.size() << std::endl;
    // std::cerr << "fullSize = " << fullSize << std::endl;

        if (chain.size() < fullSize){
            chain.reserve (fullSize);
            for (int i = chain.size()-2; i > 0; --i){
                if (mainLeadingDegree_AA (chain[i].poly) != mainLeadingDegree_AA (chain[i-1].poly) + 1) {
                    delta = mainLeadingDegree_AA (chain[i].poly) - mainLeadingDegree_AA (chain[i-1].poly);
                    if (i > 1) {
                        i = i-1;
                        for (int j = 0; j < delta-2; ++j)
                            chain.insert (chain.begin()+i,zero);
                    }
                    else {
                        for (int j=0; j<delta-1; ++j)
                            chain.insert(chain.begin()+i,zero);
                    }
                }
            }
            if (mainLeadingDegree_AA (chain[0].poly) != 0){
                for (int j = 0; j < mainLeadingDegree_AA (chain[0].poly); ++j){
                    chain.insert (chain.begin(),zero);
                }
            }
        }
    // std::cerr << "chain.size() = " << chain.size() << std::endl;

        return chain;
    }

    return subr;
    } else {
    // Subresultant from SUP: 
        std::cout << "SUP Subresultant" << std::endl;
        std::vector<SparseMultivariateRationalPolynomial> Out;
        std::vector<SparseUnivariatePolynomial<SparseMultivariateRationalPolynomial>> S;
        SparseUnivariatePolynomial<SparseMultivariateRationalPolynomial> a, b;
        SparseMultivariateRationalPolynomial temp;
        if (q.leadingVariableDegree() > leadingVariableDegree()) {
            a = q.convertToSUP(v);
            b = convertToSUP(v);
        }
        else {
            a = convertToSUP(v);
            b = q.convertToSUP(v);
        }
        S = a.subresultantChain(b);
        Out.reserve(S.size());
        for (int i=0; i<S.size(); ++i) {
            temp = SparseMultivariateRationalPolynomial(S[i]);
            Out.push_back(temp);
        }
        return Out;
    }
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::resultant (const SparseMultivariateRationalPolynomial& q) const {
    
    Symbol v = q.leadingVariable();
    if (v != leadingVariable()) {
        std::cout << "BPAS: error, cannot compute subresultant chain if leading variable of input is different from leading variable of the current object." << std::endl;
        exit(1);
    }
    
    // // resultant from SMZP:
    
    std::vector<int> xs;
    bool isOrdered = isOrderedRing(q, xs);
    SparseMultivariateRationalPolynomial ppP, ppQ;
    std::vector<SparseMultivariateRationalPolynomial> subr;
    
    if (!isOrdered) {
        std::cout << "BPAS: error, trying to add between Q[";
        for (int i = 1; i <= nvar; ++i) {
            std::cout << names[i];
            if (i < nvar) { std::cout << ", "; }
        }
        std::cout << "] and Q[";
        for (int i = 1; i <= q.nvar; ++i) {
            std::cout << q.names[i];
            if (i < q.nvar) { std::cout << ", "; }
        }
        std::cout << "]." << std::endl;
        exit(1);
    }
    
    int superNvar = xs.size() / 2;
    if (superNvar != nvar || superNvar != q.nvar) {
	
        //map indices to the expanded superset. 
        int varmap[nvar];
        int qvarmap[q.nvar];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                varmap[xs[i]-1] = i/2;
            }
            if (xs[i+1] != 0) {
                qvarmap[xs[i+1]-1] = i/2;
            }
        }
	
        //create new combined names array
        Symbol newnames[superNvar+1];
        //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
        newnames[0] = this->names[0];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                newnames[(i/2) + 1] = names[xs[i]];
            } else {
                newnames[(i/2) + 1] = q.names[xs[i+1]];
            }
        }
	
    	ppP = this->expandVariables(superNvar, newnames, varmap);
        ppQ = q.expandVariables(superNvar, newnames, qvarmap);
    	// ppP = ppP.primitivePart();
    	// ppQ = ppQ.primitivePart();
    } else {
	ppP = *this;
	ppQ = q;
	
	// ppP = this->primitivePart();
    	// ppQ = q.primitivePart();
    }    

    AltArr_t* Pq = primitivePart_AA (ppP.poly);
    AltArr_t* Qq = primitivePart_AA (ppQ.poly);
    
    AltArrZ_t* P = deepCopyPolynomial_AAZFromAA (Pq);
    AltArrZ_t* Q = deepCopyPolynomial_AAZFromAA (Qq);
    
    freePolynomial_AA (Pq);
    freePolynomial_AA (Qq);
    
    // // std::cout << "\n\n\n\n";
    // // std::cout << "ppP := " << ppP << std::endl;
    // // std::cout << "ppQ := " << ppQ << std::endl;
    
    // AltArrZ_t* P = deepCopyPolynomial_AAZFromAA (ppP.poly);
    // AltArrZ_t* Q = deepCopyPolynomial_AAZFromAA (ppQ.poly);
    
    AltArr_t* res = deepCopyPolynomial_AAFromAAZ (DucosResultantZ (P,Q));
    freePolynomial_AAZ (P);
    freePolynomial_AAZ (Q);
    return SparseMultivariateRationalPolynomial (res, ppP.nvar, ppP.names);
}

/**
 * Subresultant Chain GCD
 * Return the last non-zero subresultant of the current polynomial and the input polynomial if the resultant is zero and return 1 otherwise
 *
 * @param q: The other sparse univariate polynomial
 **/
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::subresultantGCD (const SparseMultivariateRationalPolynomial& q) const {
    Symbol v = q.leadingVariable();
    SparseMultivariateRationalPolynomial one;
    one.one();  
    if (v != leadingVariable()) {
        return one;
        // std::cout << "BPAS: error, cannot compute subresultant gcd if leading variable of input is different from leading variable of the current object." << std::endl;
        // exit(1);
    }
    
    if (isConstant() || q.isConstant()) {
        return one;
    }
    
    if (this->numberOfRingVariables() == 1 || q.numberOfRingVariables() == 1) {
        return this->primitiveGCD(q);
    }
    // // // 
    // GCD from C++ side:
    //startTimer(&start);
    std::vector<SparseMultivariateRationalPolynomial> src = subresultantChain(q);
    
    //  for (int i=0; i<src.size(); ++i)
    //      std::cerr << "src[" << i << "] = " << src[i] << std::endl;
    if (!src[0].isZero()) {
    	//      stopTimer(&start,&elapsed);
    	//      std::cerr << "SUP gcd time: " << elapsed << std::endl;
    	return one;
    }
    else {
    	if (src[2].degree(v) == src[1].degree(v)) {
    	    //          stopTimer(&start,&elapsed);
    	    //          std::cerr << "SUP gcd time: " << elapsed << std::endl;
    	    return src[2];
    	}
    	else {
    	    //          stopTimer(&start,&elapsed);
    	    //          std::cerr << "SUP gcd time: " << elapsed << std::endl;
    	    return src[1];
    	}
    }
    // // //
    
    // // // //
    // // GCD from C side:
    
    // SparseMultivariateRationalPolynomial ppP = this->primitivePart();
    // SparseMultivariateRationalPolynomial ppQ = q.primitivePart();
    // AltArrZ_t* P = deepCopyPolynomial_AAZFromAA (ppP.poly);
    // AltArrZ_t* Q = deepCopyPolynomial_AAZFromAA (ppQ.poly);
    // AltArr_t* gcd;
    // gcd = deepCopyPolynomial_AAFromAAZ (DucosGCDZ (P, Q));
    // return SparseMultivariateRationalPolynomial (gcd, nvar, names);   
    // // // // 
}

/**
 * Get the GCD between this and b.
 * If this and b have all integer coefficients, the gcd will have integer coefficients
 * with proper GCD among those coefficients. Otherwise, the returned GCD is monic
 * with rational number coefficients. 
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::gcd(const SparseMultivariateRationalPolynomial& b) const {

    bool TYPE = 0; // 0: gcd_AAZ, 1: primitiveGCD
    SparseMultivariateRationalPolynomial ret;
    
    if (TYPE == 0){
	// std::cout << "[Ali-TEST] computing SMQP::gcd ... " << std::endl;
	std::vector<int> xs;
	bool isOrdered = isOrderedRing(b, xs);
	SparseMultivariateRationalPolynomial ppP, ppQ;

	// // TEST
	// std::cout << "BPAS : *this := " << *this << std::endl;
	// std::cout << "BPAS : b := " << b << std::endl;
	
	if (!isOrdered) {
	    std::cout << "BPAS: error, trying to compute gcd  between Q[";
	    for (int i = 1; i <= nvar; ++i) {
		std::cout << names[i];
		if (i < nvar) { std::cout << ", "; }
	    }
	    std::cout << "] and Q[";
	    for (int i = 1; i <= b.nvar; ++i) {
		std::cout << b.names[i];
		if (i < b.nvar) { std::cout << ", "; }
	    }
	    std::cout << "]." << std::endl;
	    exit(1);
	}
    
	int superNvar = xs.size() / 2;
	if (superNvar != nvar || superNvar != b.nvar) {
	
	    //map indices to the expanded superset. 
	    int varmap[nvar];
	    int bvarmap[b.nvar];
	    for (int i = 0; i < xs.size(); i += 2) {
		if (xs[i] != 0) {
		    varmap[xs[i]-1] = i/2;
		}
		if (xs[i+1] != 0) {
		    bvarmap[xs[i+1]-1] = i/2;
		}
	    }
	
	    //create new combined names array
	    Symbol newnames[superNvar+1];
	    //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
	    newnames[0] = this->names[0];
	    for (int i = 0; i < xs.size(); i += 2) {
		if (xs[i] != 0) {
		    newnames[(i/2) + 1] = names[xs[i]];
		} else {
		    newnames[(i/2) + 1] = b.names[xs[i+1]];
		}
	    }
	
	    ppP = this->expandVariables(superNvar, newnames, varmap);
	    ppQ = b.expandVariables(superNvar, newnames, bvarmap);
	    // ppP = ppP.primitivePart();
	    // ppQ = ppQ.primitivePart();
	} else {
	    ppP = *this;
	    ppQ = b;
	    
	    // ppP = this->primitivePart();
	    // ppQ = b.primitivePart();
	}    

	AltArr_t* Pq = primitivePart_AA (ppP.poly);
	AltArr_t* Qq = primitivePart_AA (ppQ.poly);
	
	AltArrZ_t* P = deepCopyPolynomial_AAZFromAA (Pq);
	AltArrZ_t* Q = deepCopyPolynomial_AAZFromAA (Qq);

	// TODO: uncomment :
	// freePolynomial_AA (Pq);
	// freePolynomial_AA (Qq);
	
	// std::cout << "\n\n\n\n";
	// std::cout << "ppP := " << ppP << std::endl;
	// std::cout << "ppQ := " << ppQ << std::endl;
	
	// AltArrZ_t* P = deepCopyPolynomial_AAZFromAA (ppP.poly);
	// AltArrZ_t* Q = deepCopyPolynomial_AAZFromAA (ppQ.poly);

	// std::cout << "[Ali-TEST] nvar(P) = " << P->nvar << std::endl;
	// std::cout << "[Ali-TEST] nvar(Q) = " << Q->nvar << std::endl;	

	// SparseMultivariateRationalPolynomial test_P (deepCopyPolynomial_AA (Pq), ppP.nvar, ppP.names);
	// std::cout << "[Ali-TEST] P = "  << test_P << std::endl;
	
	// SparseMultivariateRationalPolynomial test_Q (deepCopyPolynomial_AA (Qq), ppP.nvar, ppP.names);
	// std::cout << "[Ali-TEST] Q = "  << test_Q << std::endl;

	AltArrZ_t* gz = gcd_AAZ (P, Q);
	// std::cout << "[Ali-TEST] gcd_AAZ from SMQP::gcd is done... " << std::endl;

	// std::cout << "[Ali-TEST] gcd_AAZ from SMQP::gcd is called... " << std::endl;
	
	AltArr_t* g = deepCopyPolynomial_AAFromAAZ (gz);
	freePolynomial_AAZ (P);
	freePolynomial_AAZ (Q);
	freePolynomial_AAZ (gz);
	
	SparseMultivariateRationalPolynomial gcd (g, ppP.nvar, ppP.names);
	ret = gcd;
	// gcd += ppP.content() * ppQ.content();
	// return SparseMultivariateRationalPolynomial (gcd);
	
    } else {
	ret = this->primitiveGCD(b);
    }
    
    mpz_t g1;
    mpz_t g2;
    mpz_init(g1);
    mpz_init(g2);
    integerPolynomialTest_AA(this->poly, g1);
    integerPolynomialTest_AA(b.poly, g2);
    if (mpz_cmp_si(g1, 0l) != 0 && mpz_cmp_si(g2, 0l) != 0) {
	//they are both integer polys
	mpz_gcd(g1, g1, g2);
	ret *= RationalNumber(g1);
    } else if (!ret.isConstant()) {
	ret /= ret.leadingCoefficient();        
    }
    
    mpz_clear(g1);
    mpz_clear(g2);
	
    return ret;

}


/**
 * Get GCD between *this and b as a primitive polynomial.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::primitiveGCD(const SparseMultivariateRationalPolynomial& b) const {
    if (isZero()) {
        return b;
    }
    if (b.isZero()) {
        return *this;
    }

    if (isConstant() || b.isConstant()) {
        SparseMultivariateRationalPolynomial ret;
        ret.one();
        return ret;
    //     mpz_t mpzG;
    //     mpz_init(mpzG);
    //     mpz_set_ui(mpzG, 1l);
    //     if (b.isConstant() && mpz_cmp_si(mpq_denref(b.poly->elems->coef), 1l) == 0) {
    //         std::cerr << "b is constant and integer" << std::endl;
    //         mpz_set(mpzG, mpq_numref(b.poly->elems->coef));
    //         for (int i = 0; i < this->poly->size; ++i) {
    //             gmp_fprintf(stderr, "gcd: %Zd, this coef: %Qd\n", mpzG, this->poly->elems[i].coef);
    //             if (mpz_cmp_si(mpq_denref(this->poly->elems[i].coef), 1l) != 0) {
    //                 mpz_set_ui(mpzG, 1l);
    //                 break;    
    //             }
    //             mpz_gcd(mpzG, mpzG, mpq_numref(this->poly->elems[i].coef));
    //             gmp_fprintf(stderr, "gcd: %Zd\n", mpzG);
    //             if (mpz_cmp_si(mpzG, 1l) == 0) {
    //                 break;
    //             }
    //         }
    //     } else if (mpz_cmp_si(mpq_denref(poly->elems->coef), 1l) == 0) {
    //         std::cerr << "this is constant and integer" << std::endl;
    //         mpz_set(mpzG, mpq_numref(this->poly->elems->coef));
    //         for (int i = 0; i < b.poly->size; ++i) {
    //             gmp_fprintf(stderr, "gcd: %Zd, b coef: %Qd\n", mpzG, b.poly->elems[i].coef);
    //             if (mpz_cmp_si(mpq_denref(b.poly->elems[i].coef), 1l) != 0) {
    //                 mpz_set_ui(mpzG, 1l);
    //                 break;    
    //             }
    //             mpz_gcd(mpzG, mpzG, mpq_numref(b.poly->elems[i].coef));
    //             gmp_fprintf(stderr, "gcd: %Zd\n", mpzG);
    //             if (mpz_cmp_si(mpzG, 1l) == 0) {
    //                 break;
    //             }
    //         }
    //     }

    //     RationalNumber mpzc(mpzG);
    //     SparseMultivariateRationalPolynomial ret(mpzc);
    //     std::cerr << "mpzc: " << mpzc << " ret: " << ret << std::endl;
    //     mpz_clear(mpzG);
    //     return ret;
    }

    std::vector<int> xs;
    if (!isOrderedRing(b, xs)) {
        SparseMultivariateRationalPolynomial ret(0);
        ret.one();
        return ret;
    }    

    if (this->nvar == 1 && b.nvar == 1) {
        if (xs.size() > 2) {
            SparseMultivariateRationalPolynomial ret(0);
            ret.one();
            return ret;
        }

        //otherwise they are the same variables
        AltArr_t* g = univariateGCD_AA(this->poly, b.poly);
        if (isZeroExponentVector(g->elems->degs)) {
            SparseMultivariateRationalPolynomial ret(g, 0, names);
            return ret;
        }
        SparseMultivariateRationalPolynomial ret(g, nvar, names);
        return ret;
    }
    if (this->nvar == 1) {
        std::vector<Symbol> vars = b.ringVariables();
        int match = -1;
        for (int i = 0; i < b.nvar; ++i) {
            if (vars[i] == names[1]) {
                match = i;
                break;
            }
        }
        if (match < 0) {
            SparseMultivariateRationalPolynomial ret(0);
            ret.one();
            return ret;
        }

        vars.erase(vars.begin()+match);

        SparseMultivariateRationalPolynomial newB = b.content(vars);
        
        //it is possible that the content that comes back is an integral content.
        if (newB.nvar == 0) {
            //recursive call to handle is isContstant() case above
            return this->primitiveGCD(newB);
        }

        AltArr_t* g = univariateGCD_AA(this->poly, newB.poly);
        if (isZeroExponentVector(g->elems->degs)) {
            SparseMultivariateRationalPolynomial ret(g, 0, names);
            return ret;
        }
        SparseMultivariateRationalPolynomial ret(g, nvar, names);
        return ret;
    } else if (b.nvar == 1) {
        std::vector<Symbol> vars = this->ringVariables();
        int match = -1;
        for (int i = 0; i < nvar; ++i) {
            if (vars[i] == b.names[1]) {
                match = i;
                break;
            }
        }
        if (match < 0) {
            SparseMultivariateRationalPolynomial ret(0);
            ret.one();
            return ret;
        }

        vars.erase(vars.begin()+match);

        SparseMultivariateRationalPolynomial newThis = this->content(vars);

        //it is possible that the content that comes back is an integral content.
        if (newThis.nvar == 0) {
            //recursive call to handle is isContstant() case above
            return b.primitiveGCD(newThis);
        }

        AltArr_t* g = univariateGCD_AA(newThis.poly, b.poly);
        if (isZeroExponentVector(g->elems->degs)) {
            SparseMultivariateRationalPolynomial ret(g, 0, names);
            return ret;
        }
        SparseMultivariateRationalPolynomial ret(g, b.nvar, b.names);
        return ret;
    }   

    int superNvar = xs.size() / 2;
    if (superNvar != nvar || superNvar != b.nvar) {
        //map indices to the expanded superset. 
        int varmap[nvar];
        int bvarmap[b.nvar];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                varmap[xs[i]-1] = i/2;
            }
            if (xs[i+1] != 0) {
                bvarmap[xs[i+1]-1] = i/2;
            }
        }

        //create new combined names array
        Symbol newnames[superNvar+1];
        //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
        newnames[0] = this->names[0];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                newnames[(i/2) + 1] = names[xs[i]];
            } else {
                newnames[(i/2) + 1] = b.names[xs[i+1]];
            }
        }

        SparseMultivariateRationalPolynomial tempa = this->expandVariables(superNvar, newnames, varmap);
        SparseMultivariateRationalPolynomial tempb = b.expandVariables(superNvar, newnames, bvarmap);
        

        std::vector<Symbol> vars;
        vars.push_back(newnames[1]);
        SparseMultivariateRationalPolynomial tC = tempa.content(vars);
        SparseMultivariateRationalPolynomial bC = tempb.content(vars);
        SparseMultivariateRationalPolynomial g = tC.primitiveGCD(bC);

        SparseMultivariateRationalPolynomial tPP = tempa / tC;
        SparseMultivariateRationalPolynomial bPP = tempb / bC;

        SparseMultivariateRationalPolynomial ppG = tPP.subresultantGCD(bPP);
        SparseMultivariateRationalPolynomial ppGP = ppG.primitivePart(vars);

        SparseMultivariateRationalPolynomial ret = g * ppGP;

        ret.setRingVariables(ret.variables());
        return ret;    
    } else {
        //exact same ring, easy.
        std::vector<Symbol> vars;
        vars.push_back(names[1]);
        SparseMultivariateRationalPolynomial tC = this->content(vars);
        SparseMultivariateRationalPolynomial bC = b.content(vars);

        std::vector<Symbol> rVars;

        SparseMultivariateRationalPolynomial g = tC.primitiveGCD(bC);

        SparseMultivariateRationalPolynomial tPP = *this / tC;
        SparseMultivariateRationalPolynomial bPP = b / bC;

        SparseMultivariateRationalPolynomial ppG = tPP.subresultantGCD(bPP);
        SparseMultivariateRationalPolynomial ppGP = ppG.primitivePart(vars);

        SparseMultivariateRationalPolynomial ret = g * ppGP;

        ret.setRingVariables(ret.variables());
        return ret;
    }

}

Factors<SparseMultivariateRationalPolynomial> SparseMultivariateRationalPolynomial::squareFree() const {
    return this->squareFree(this->ringVariables());
}

Factors<SparseMultivariateRationalPolynomial> SparseMultivariateRationalPolynomial::squareFree(const std::vector<Symbol>& vars) const {
    Factors<SparseMultivariateRationalPolynomial> sf;
    if (isConstant() || isZero() || vars.size() == 0) {
        sf.setRingElement(*this);
        return sf;
    }

    std::vector<Symbol> nextVars;
    int strIdx = 0;
    for (int j = 0; j < vars.size(); ++j) {
        if (strIdx == 0) {
            for (int i = 0; i < nvar; ++i) {
                if (vars[j] == names[i+1]) {
                    strIdx = i+1;
                    break;
                }
            }
            if (strIdx == 0){
                nextVars.push_back(vars[j]);
            }
        } else {
            nextVars.push_back(vars[j]);
        }
    }

    if (strIdx == 0) {
        sf.setRingElement(*this);
        return sf;
    }


    std::vector<Symbol> curVars;
    curVars.push_back(names[strIdx]);
    SparseMultivariateRationalPolynomial content;
    SparseMultivariateRationalPolynomial primPart = this->primitivePart(curVars, content);

    // std::cout << "primPart = " << primPart << std::endl; 
    
    if (primPart.isConstant()) {
        if (!primPart.isOne()) {
            sf.addFactor(primPart, 1);
        }
    } else if (primPart.degree(names[strIdx]) == 1) {
        // SparseMultivariateRationalPolynomial df = primPart.leadingCoefficient(names[strIdx]);
        // SparseMultivariateRationalPolynomial g = primPart.gcd(df);
        // SparseMultivariateRationalPolynomial next = primPart / g;
        // next *= g;
        // sf.push_back(next); 

        sf.addFactor(primPart, 1); 
    } else {
        SparseMultivariateRationalPolynomial dx = primPart.derivative(names[strIdx]);
	
	// std::cout << "dx = " << dx << std::endl;

        SparseMultivariateRationalPolynomial g = (primPart.gcd(dx)).primitivePart();
	
        SparseMultivariateRationalPolynomial next = primPart / g;
        if (next.leadingCoefficient() < 1) {
            next.negate();
        }

        int k = 1;
        if (g.isOne()) {
            AltArr_t* remFact = NULL;
            AltArr_t* comFact = commonFactor_AA(next.poly, &remFact);

            if (!isZeroExponentVector(comFact->elems->degs)) {
                //next /= comFact
                AltArr_t* temp = next.poly;
                next.poly = remFact;
                freePolynomial_AA(temp);

                //set comFact exp to 1 to add to sf.
                int* sizes = getExpOffsetArray(nvar);
                degrees_t* masks = getExpMaskArray(nvar);
                temp = makeConstPolynomial_AA(1, nvar, RationalNumber(1).get_mpq_t());
                for (int j = 0; j < nvar; ++j){
                    if ( (comFact->elems->degs & masks[j]) != 0) {
                        int deg = GET_NTH_EXP(comFact->elems->degs, masks[j], sizes[j]);
                        temp->elems->degs = (1ull << sizes[j]);
                        SparseMultivariateRationalPolynomial fac(temp, nvar, names);
                        sf.addFactor(fac, deg);
                        fac.poly = NULL;
                    }
                }
                freePolynomial_AA(temp);
                free(sizes);
                free(masks);
            }
        }
        while (g.degree(names[strIdx]) > 0) {

	    
	    // std::cout << "next = " << next << std::endl;
	    // std::cout << "g = " << g << std::endl;
	    
            SparseMultivariateRationalPolynomial y = (next.gcd(g)).primitivePart();
            // std::cerr << "after primitiveGCD(g)" << std::endl;
            //don't add factors of 1.
            if (next != y) {
                sf.addFactor(next / y, k);
            }
            g /= y;
            next = y;
            if (next.leadingCoefficient() < 1) {
                next.negate();
            }
            ++k;
        }
        sf.addFactor(next, k);
    }

    //if content is constant then this recursive call will set the ringElement 
    //to be that constant. Do this instead of setting the ring constant to 
    //the integral content of this.
    // if (!content.isConstant()) {
        Factors<SparseMultivariateRationalPolynomial> contSf = content.squareFree(nextVars);
        sf.addFactors(contSf);
        sf.multiplyRingElement(contSf.ringElement());
    // }

    // //Calculate leading multiplier to return;
    // RationalNumber iCont = this->content();
    // sf.setRingElement(iCont);
	// std::cerr << "leaving squareFree(vs)..." << std::endl;
    return sf;
}

/**
 * Computes the square free part of this polynomail. That is, the polynomial of this
 * divided by all square factors. This is with respect to all variables.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::squareFreePart() const {

    int TYPE = 0; // 0: SMZP (C version), 1: SMQP (C++ version) 
    
    if (isZero())
	return *this;

    if (!TYPE) {
	SparseMultivariateRationalPolynomial ppP = this->primitivePart();
	AltArrZ_t* aaz = deepCopyPolynomial_AAZFromAA (ppP.poly);
	AltArrZ_t* sqrPart_AAZ = squareFreePart_AAZ (aaz, ppP.nvar);
	freePolynomial_AAZ (aaz);
	AltArr_t* sqrPart_AA = deepCopyPolynomial_AAFromAAZ (sqrPart_AAZ);
	freePolynomial_AAZ (sqrPart_AAZ);
	SparseMultivariateRationalPolynomial result (sqrPart_AA, ppP.nvar, ppP.names);
	return result;
    }
    
    std::vector<Symbol> vars = this->ringVariables();
    return this->squareFreePart(vars);
}

/**
 * Computes the square free part of this polynomail. That is, the polynomial of this
 * divided by all square factors. This is with respect to all variables.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::squareFreePart(std::vector<Symbol>& vars) const {
	if (isZero())
		return *this;
    std::vector<Symbol> matchedVars;
    for (int i = 0; i < vars.size(); ++i) {
        for (int j = 0; j <= nvar; ++j) {
            if (vars[i] == names[j+1]) {
                matchedVars.push_back(vars[i]);
                break;
            }
        }
    }

    SparseMultivariateRationalPolynomial cont;
    SparseMultivariateRationalPolynomial fact;
    fact.one();
    std::vector<Symbol> var;
    SparseMultivariateRationalPolynomial primpart = *this;
    for (int i = 0; i < matchedVars.size(); ++i) {
        var.clear();
        var.push_back(matchedVars[i]);
        primpart = primpart.primitivePart(var, cont);
        SparseMultivariateRationalPolynomial diff = primpart.derivative(var[0]);
        SparseMultivariateRationalPolynomial g = (primpart.gcd(diff)).primitivePart();
        SparseMultivariateRationalPolynomial next = primpart / g;
        if (next.leadingCoefficient() < 1) {
            next.negate();
        }
        fact *= next;
        if (cont.isConstant()) {
            break;
        }
        primpart = cont;      
    }

    return fact;
}

////////// Private Helpers ////////////////////////////////////

/**
 * Finds the variable superset which contains both variable orderings from *this and b, if possible.
 *
 * xs is filled such that it's length is twice that of the number of variables in 
 * the resulting superset and it's indices are such that for variable i in [0, ..., size(xs)/2)
 * in the superset is equal to this.names[xs[2*i]] if xs[2*i] != 0 and equal to
 * b.names[xs[2*i+1]] if xs[2*i+1] != 0. 
 * This means that if both xs[2*i] and xs[2*i+1] are non-zero, then the variable is shared
 * between *this and b. 
 *
 * For example, [9,x,y] and [9,s,t,x] produces [0,1,0,2,1,3,2,0]. Recall leading "9" indicates
 * user-supplied ordering. 
 *
 * returns true iff such an ordering is possible.
 */
bool SparseMultivariateRationalPolynomial::isOrderedRing(const SparseMultivariateRationalPolynomial& b, std::vector<int>& xs) const {
    // if (names[0] != b.names[0]) { return 0; }
    // if (names[0] == "1") {
    //     int k = 1;
    //     for (; k <= nvar && k <= b.nvar; ++k) {
    //         xs.push_back(k);
    //         xs.push_back(k);
    //     }
    //     for (int i = k; i <= nvar; ++i) {
    //         xs.push_back(i);
    //         xs.push_back(0);
    //     }
    //     for (int i = k; i <= b.nvar; ++i) {
    //         xs.push_back(0);
    //         xs.push_back(i);
    //     }
    //     return 1;
    // }
    if (!nvar) {
        for (int i = 1; i <= b.nvar; ++i) {
            xs.push_back(0);
            xs.push_back(i);
        }
        return 1;
    }
    if (!b.nvar) {
        for (int i = 1; i <= nvar; ++i) {
            xs.push_back(i);
            xs.push_back(0);
        }
        return 1;
    }

    bool isFound = 0;
    int* pos = new int[nvar];
    for (int i = 1; i <= nvar; ++i) {
        isFound = 0;
        for (int j = 1; j <= b.nvar; ++j) {
            if (names[i] == b.names[j]) {
                pos[i-1] = j;
                isFound = 1;
                break;
            }
        }
        if (!isFound) { pos[i-1] = 0; }
    }

    isFound = 0;
    int ak = 1, bk = pos[0];
    if (pos[0]) {
        for(int j = 1; j < pos[0]; ++j) {
            xs.push_back(0);
            xs.push_back(j);
        }
        xs.push_back(1);
        xs.push_back(pos[0]);
    }
    for (int i = 1; i < nvar; ++i) {
        if (pos[i] > bk) {
            while (pos[i] - bk > 1 && (i > ak || !bk)) {
                if (bk) { ak++; }
                bk++;
                if (names[ak] < b.names[bk]) {
                    xs.push_back(ak);
                    xs.push_back(0);
                    xs.push_back(0);
                    xs.push_back(bk);
                }
                else if (names[ak] > b.names[bk]) {
                    xs.push_back(0);
                    xs.push_back(bk);
                    xs.push_back(ak);
                    xs.push_back(0);
                }
            }
            for(int j = bk+1; j < pos[i]; ++j) {
                xs.push_back(0);
                xs.push_back(j);
            }
            for(int j = (!bk)? ak : ak+1; j <= i; ++j) {
                xs.push_back(j);
                xs.push_back(0);
            }
            xs.push_back(i+1);
            xs.push_back(pos[i]);
            bk = pos[i];
            ak = i + 1;
        }
        else if (pos[i] && pos[i] < bk) {
            isFound = 1;
            break;
        }
    }
    if (!isFound) {
        for (int i = (bk)? ak+1 : ak, j = bk+1; i <= nvar && j <= b.nvar; ++i, ++j) {
            if (names[i] < b.names[j]) {
                xs.push_back(i);
                xs.push_back(0);
                xs.push_back(0);
                xs.push_back(j);
            }
            else if (names[i] > b.names[j]) {
                xs.push_back(0);
                xs.push_back(j);
                xs.push_back(i);
                xs.push_back(0);
            }
            ak = i, bk = j;
        }
        for (int i = ak+1; i <= nvar; ++i) {
            xs.push_back(i);
            xs.push_back(0);
        }
        for (int j = bk+1; j <= b.nvar; ++j) {
            xs.push_back(0);
            xs.push_back(j);
        }
    }

    delete [] pos;

    if (isFound) { xs.clear(); return 0; }
    else { return 1; }
}

/** 
 * Returns a copy of *this under the new variable ordering supplied. 
 * varmap is such that this.names[i] = newvars[varmap[i]]
 * Returns an SMQP equal to *this but expended to newvars.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::expandVariables(int vars, Symbol* newvars, int varmap[]) const {
    if (isZero()) {
        SparseMultivariateRationalPolynomial temp(NULL, vars, newvars);
        return temp;
    }
    if (isConstant()) {
        AltArr_t* tempPoly = makePolynomial_AA(1, vars);
        mpq_init(tempPoly->elems->coef);
        mpq_set(tempPoly->elems->coef, poly->elems->coef);
        tempPoly->elems->degs = 0;
        tempPoly->size = 1;

        SparseMultivariateRationalPolynomial temp(tempPoly, vars, newvars);
        return temp;
    }


    AltArr_t* tempPoly = deepCopyPolynomial_AA(poly);
    expandNumVars_AA(tempPoly, vars);
    reorderVars_AA(tempPoly, varmap, nvar);

    SparseMultivariateRationalPolynomial temp(tempPoly, vars, newvars);       
    return temp;
}

void SparseMultivariateRationalPolynomial::expandVarsInPlace(int vars, Symbol* newvars, int varmap[]) {
    if (isZero() || isConstant()) {
        if (poly != NULL) {
            poly->nvar = vars;
        }
    } else {
        expandNumVars_AA(poly, vars);
        
        //here we use nvar and vars as # of vars as varmap is of size nvar.
        reorderVars_AA(poly, varmap, nvar);
    }

    nvar = vars;
    delete[] names;
    names = new Symbol[vars+1];
    std::copy(newvars, newvars+vars+1, names);
}

/** 
 * Rearrange exponent vectors in place and then re-sort the polynomial.
 */
void SparseMultivariateRationalPolynomial::reorderVarsInPlace(int varmap[]) {
    if (isZero()) {
        return;
    }
    if (isConstant()) {
        return;
    }
    
    reorderVars_AA(poly, varmap, nvar);
    Symbol* newvars = new Symbol[nvar+1];
    newvars[0] = names[0];
    for (int i = 0; i < nvar; ++i) {
        newvars[varmap[i]+1] = names[i+1]; 
    }
    delete[] names;
    names = newvars;

} 

////////// BPASPolynomial ////////////////////////////////////

SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator= (const SparseMultivariateRationalPolynomial& b) {
    if (this != &b) {
        freePolynomial_AA(poly);
        poly = deepCopyPolynomial_AA(b.poly);
        
        nvar = b.nvar;
        delete[] names; 
        names = new Symbol[nvar+1];
        std::copy(b.names, b.names+nvar+1, names);
        slp = b.slp;
    }
    return *this;
}

/**
 * Movement assignment: move b to be this polynomail.
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator= (SparseMultivariateRationalPolynomial&& b) {
    if (this != &b) {
        freePolynomial_AA(poly);
        poly = b.poly;
        b.poly = NULL;
        nvar = b.nvar;
        b.nvar = 0;

        delete[] names;
        names = new Symbol[nvar+1];
        std::copy(b.names, b.names+nvar+1, names);

        slp = b.slp;
        b.slp.clear();
    }
    return *this;
}

SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator= (const RationalNumber& r) {
    if (poly != NULL) {
        freePolynomial_AA(poly);
        poly = NULL;
    }
    
    slp.clear();
    poly = makeConstPolynomial_AA(1, nvar, r.get_mpq_t());

    return *this;
}


SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator+ (const SparseMultivariateRationalPolynomial& b) const {
    if (b.isZero()) {
        return *this;
    } 
    if (isZero()) {
        return b;
    }
    if (this->isConstant() != 0) {
        return (b + this->poly->elems->coef);
    }
    if (b.isConstant() != 0) {
        return (*this + b.poly->elems->coef);
    }

    std::vector<int> xs;
    bool isOrdered = isOrderedRing(b, xs);

    if (!isOrdered) {
        std::cout << "BPAS: error, trying to add between Q[";
        for (int i = 1; i <= nvar; ++i) {
            std::cout << names[i];
            if (i < nvar) { std::cout << ", "; }
        }
        std::cout << "] and Q[";
        for (int i = 1; i <= b.nvar; ++i) {
            std::cout << b.names[i];
            if (i < b.nvar) { std::cout << ", "; }
        }
        std::cout << "]." << std::endl;
        exit(1);
    }

    int superNvar = xs.size() / 2;
    if (superNvar != nvar || superNvar != b.nvar) {

        //map indices to the expanded superset. 
        int varmap[nvar];
        int bvarmap[b.nvar];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                varmap[xs[i]-1] = i/2;
            }
            if (xs[i+1] != 0) {
                bvarmap[xs[i+1]-1] = i/2;
            }
        }

        //create new combined names array
        Symbol newnames[superNvar+1];
        //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
        newnames[0] = this->names[0];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                newnames[(i/2) + 1] = names[xs[i]];
            } else {
                newnames[(i/2) + 1] = b.names[xs[i+1]];
            }
        }

        SparseMultivariateRationalPolynomial tempa = this->expandVariables(superNvar, newnames, varmap);
        SparseMultivariateRationalPolynomial tempb = b.expandVariables(superNvar, newnames, bvarmap);
        
        AltArr_t* sum = addPolynomials_AA(tempa.poly, tempb.poly, superNvar);
        SparseMultivariateRationalPolynomial ret(sum, superNvar, newnames);
        return ret;
    
    } else {
        AltArr_t* sum = addPolynomials_AA(poly, b.poly, nvar);
        SparseMultivariateRationalPolynomial ret(sum, nvar, names);
        return ret;
    }
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator+ (SparseMultivariateRationalPolynomial&& b) const {
    SparseMultivariateRationalPolynomial ret = b;
    ret += *this;
    return ret;
}

// SparseMultivariateRationalPolynomial operator+ (SparseMultivariateRationalPolynomial&& a, const SparseMultivariateRationalPolynomial& b) {
//     SparseMultivariateRationalPolynomial ret = a;
//     ret += b;
//     return ret;
// }

SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator+= (const SparseMultivariateRationalPolynomial& b) {
    if (nvar == b.nvar) {
//    	std::cerr << "nvar: " << nvar << std::endl;
//    	std::cerr << "this: " << *this << std::endl;
//    	std::cerr << "b   : " << b << std::endl;
    	
    
        std::vector<int> xs;
        bool isOrdered = isOrderedRing(b, xs);
        int superNvar = xs.size() / 2;
        if (isOrdered && superNvar == nvar) {
            this->poly = addPolynomials_AA_inp(this->poly, b.poly, nvar); 
            return *this;
        }
    }

    *this = (*this + b);
    return *this;
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator- () const {
    SparseMultivariateRationalPolynomial temp = *this;
    temp.negate();
    return temp;
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator- (const SparseMultivariateRationalPolynomial& b) const {
    if (b.isZero()) {
        return *this;
    } 
    if (isZero()) {
        return -b;
    }
    if (this->isConstant() != 0) {
        SparseMultivariateRationalPolynomial negB = -b;
        return (negB + this->poly->elems->coef);
    }
    if (b.isConstant() != 0) {
        return (*this - b.poly->elems->coef);
    }


    std::vector<int> xs;
    bool isOrdered = isOrderedRing(b, xs);

    if (!isOrdered) {
        std::cout << "BPAS: error, trying to subtract between Q[";
        for (int i = 1; i <= nvar; ++i) {
            std::cout << names[i];
            if (i < nvar) { std::cout << ", "; }
        }
        std::cout << "] and Q[";
        for (int i = 1; i <= b.nvar; ++i) {
            std::cout << b.names[i];
            if (i < b.nvar) { std::cout << ", "; }
        }
        std::cout << "]." << std::endl;
        exit(1);
    }

    int superNvar = xs.size() / 2;
    if (superNvar != nvar || superNvar != b.nvar) {

        //map indices to the expanded superset. 
        int varmap[nvar];
        int bvarmap[b.nvar];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                varmap[xs[i]-1] = i/2;
            }
            if (xs[i+1] != 0) {
                bvarmap[xs[i+1]-1] = i/2;
            }
        }

        //create new combined names array
        Symbol newnames[superNvar+1];
        //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
        newnames[0] = this->names[0];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                newnames[(i/2) + 1] = names[xs[i]];
            } else {
                newnames[(i/2) + 1] = b.names[xs[i+1]];
            }
        }

        SparseMultivariateRationalPolynomial tempa = this->expandVariables(superNvar, newnames, varmap);
        SparseMultivariateRationalPolynomial tempb = b.expandVariables(superNvar, newnames, bvarmap);
        
        AltArr_t* sum = subPolynomials_AA(tempa.poly, tempb.poly, superNvar);
        SparseMultivariateRationalPolynomial ret(sum, superNvar, newnames);
        return ret;
    
    } else {
        AltArr_t* sum = subPolynomials_AA(poly, b.poly, nvar);
        SparseMultivariateRationalPolynomial ret(sum, nvar, names);
        return ret;
    }
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator- (SparseMultivariateRationalPolynomial&& b) const {
    SparseMultivariateRationalPolynomial ret = b;
    ret -= *this;
    return ret;   
}

// SparseMultivariateRationalPolynomial operator- (SparseMultivariateRationalPolynomial&& a, const SparseMultivariateRationalPolynomial& b) {
//     SparseMultivariateRationalPolynomial ret = a;
//     ret -= b;
//     return ret;
// }

SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator-= (const SparseMultivariateRationalPolynomial& b) {
    if (nvar == b.nvar) {
        std::vector<int> xs;
        bool isOrdered = isOrderedRing(b, xs);
        int superNvar = xs.size() / 2;
        if (isOrdered && superNvar == nvar) {
            this->poly = subPolynomials_AA_inp(this->poly, b.poly, nvar); 
            return *this;
        }
    }

    *this = (*this - b);
    return *this;
}

/**
 * Multiply *this by the specified polynomail.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator* (const SparseMultivariateRationalPolynomial& b) const {
    if (b.isZero() || this->isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }
    if (this->isConstant() != 0) {
        return (b * this->poly->elems->coef);
    }
    if (b.isConstant() != 0) {
        return (*this * b.poly->elems->coef);
    }

    std::vector<int> xs;
    bool isOrdered = isOrderedRing(b, xs);

    if (!isOrdered) {
        std::cout << "BPAS: error, trying to multiply between Q[";
        for (int i = 1; i <= nvar; ++i) {
            std::cout << names[i];
            if (i < nvar) { std::cout << ", "; }
        }
        std::cout << "] and Q[";
        for (int i = 1; i <= b.nvar; ++i) {
            std::cout << b.names[i];
            if (i < b.nvar) { std::cout << ", "; }
        }
        std::cout << "]." << std::endl;
        exit(1);
    }

    int superNvar = xs.size() / 2;
    if (superNvar != nvar || superNvar != b.nvar) {

        //map indices to the expanded superset. 
        int varmap[nvar];
        int bvarmap[b.nvar];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                varmap[xs[i]-1] = i/2;
            }
            if (xs[i+1] != 0) {
                bvarmap[xs[i+1]-1] = i/2;
            }
        }

         //create new combined names array
        Symbol newnames[superNvar+1];
        //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
        newnames[0] = this->names[0];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                newnames[(i/2) + 1] = names[xs[i]];
            } else {
                newnames[(i/2) + 1] = b.names[xs[i+1]];
            }
        }

        SparseMultivariateRationalPolynomial tempa = this->expandVariables(superNvar, newnames, varmap);
        SparseMultivariateRationalPolynomial tempb = b.expandVariables(superNvar, newnames, bvarmap);
        AltArr_t* prod = multiplyPolynomials_AA(tempa.poly, tempb.poly, superNvar);
        SparseMultivariateRationalPolynomial ret(prod, superNvar, newnames);
        return ret;
    
    } else {
        AltArr_t* prod = multiplyPolynomials_AA(poly, b.poly, nvar);
        SparseMultivariateRationalPolynomial ret(prod, nvar, names);    
        return ret;
    }
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator* (SparseMultivariateRationalPolynomial&& b) const {
    SparseMultivariateRationalPolynomial ret = b;
    ret *= *this;
    return ret;   
}

// SparseMultivariateRationalPolynomial operator* (SparseMultivariateRationalPolynomial&& a, const SparseMultivariateRationalPolynomial& b) {
//     SparseMultivariateRationalPolynomial ret = a;
//     ret *= b;
//     return ret;
// }

/**
 * Update this by multiplying by the specified polynomail.
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator*= (const SparseMultivariateRationalPolynomial& b) {
    *this = (*this * b);
    return *this;
}

/**
 * Divide *this by the specified polynomial.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator/ (const SparseMultivariateRationalPolynomial& b) const {
    std::vector<Symbol> vars = this->ringVariables();
    // std::cerr << "in operator/" << std::endl;
    // std::cerr << "t nvar: " << this->nvar << std::endl;
    // std::cerr << "this v: " << this->names[0] << std::endl;
    // for (auto v : vars) {
        // std::cerr << "this v: " << v << std::endl;
    // }
    // vars = b.ringVariables();
    // std::cerr << "b nvar: " << b.nvar << std::endl;
    // std::cerr << "b    v: " << b.names[0] << std::endl;
    // for (auto v : vars) {
        // std::cerr << "b    v: " << v << std::endl;
    // }

    SparseMultivariateRationalPolynomial q,r;
    // std::cerr << "calling divide" << std::endl;

    this->divide(b, q, r);
    if (!r.isZero()) {
        std::cerr << "BPAS ERROR: SMQP non-exact division." << std::endl;
        std::cerr << "dividend: " << *this << std::endl;
        std::cerr << "divisor: " << b << std::endl;
        std::cerr << "quoteint: " << q << std::endl;
        std::cerr << "remainder: " << r << std::endl;
        exit(1);
    }
    // std::cerr << "quoteint: " << q << std::endl;
    // std::cerr << "remainder: " << r << std::endl;

    return q;
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator/ (SparseMultivariateRationalPolynomial&& b) const {
    SparseMultivariateRationalPolynomial ret = b;
    ret /= *this;
    return ret;   
}

// SparseMultivariateRationalPolynomial operator/ (SparseMultivariateRationalPolynomial&& a, const SparseMultivariateRationalPolynomial& b) {
//     SparseMultivariateRationalPolynomial ret = a;
//     ret /= b;
//     return ret;
// }

/**
 * Update *this by dividing by the specified polynomial.
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator/= (const SparseMultivariateRationalPolynomial& b){
    *this = (*this / b);
    return *this;
}

/**
 * Exponentiate *this by the input exponent integer.
 * Treats negative exponents as positive.
 */ 
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator^ (long long int e) const {
    if (e == 0) {
        SparseMultivariateRationalPolynomial ret(NULL, nvar, names);
        ret.one();
        return ret;
    } 

    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    if (e == 1) {
        return SparseMultivariateRationalPolynomial(*this);
    }

    e = (e < 0) ? -e : e;
    AltArr_t* retPoly = exponentiatePoly_AA(poly, e, nvar);
    SparseMultivariateRationalPolynomial ret(retPoly, nvar, names);
    return ret;
}

/**
 * Update *this by exponentiating this to the input integer.
 * Treats negative exponents as positive.
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator^= (long long int e) {
    *this = (*this ^ e);
    return *this;
}

/**
 * Determine if *this is equal to the specified polynomial.
 * This takes into account the variable ordering on both poylnomials 
 * in such a way that the same polynomial under different variable orderings
 * are NOT equal.
 */ 
bool SparseMultivariateRationalPolynomial::operator== (const SparseMultivariateRationalPolynomial& b) const {
    return this->isEqual(b);
}

/**
 * Determine if *this is not equal to the specified polynomial.
 * This takes into account the variable ordering on both poylnomials 
 * in such a way that the same polynomial under different variable orderings
 * are NOT equal.
 */
bool SparseMultivariateRationalPolynomial::operator!= (const SparseMultivariateRationalPolynomial& b) const {
    return !this->isEqual(b);
}

/**
 * Output the string representation of *this to the input ostream.
 */
void SparseMultivariateRationalPolynomial::print(std::ostream& os) const {
    if (this->poly != NULL) {
        std::string tempVars[this->nvar];
        for (int i = 0 ; i < this->nvar; ++i) {
            tempVars[i] = this->names[i+1].toString();
        }
        os << polyToString_AA(poly, tempVars);
    } else {
        os << "0";
    }
}

std::istream& operator>>(std::istream& in, SparseMultivariateRationalPolynomial& p) {

    std::string str;
    getline(in, str);

    p.fromString(str);
    return in;
}


void SparseMultivariateRationalPolynomial::fromString(const std::string& str) {

    altarr_pack* pack = generate_altarr_pack(str.c_str());

    freePolynomial_AA(this->poly);
    this->poly = pack->altarr_t_data;
    
    delete[] this->names;
    this->names = new Symbol[pack->numVars + 1];
    for (int i = 0; i < pack->numVars; ++i) {
        names[i+1] = Symbol(std::string(pack->vars[i]));
    }

    this->nvar = pack->numVars;
    free(pack->vars);
    pack->numVars = 0;
    free(pack);
}



/**
 * Parse an input string into the current polynomial.
 */
std::istream& operator>> (std::istream& in, const SparseMultivariateRationalPolynomial& p) {
    std::cerr << "BPAS: SMQP: input stream not yet implemented";
}


RationalNumber SparseMultivariateRationalPolynomial::content() const {
    if (isZero()) {
        return RationalNumber(0);
    }
    if (isConstant()) {
        RationalNumber ret(poly->elems->coef);
        return ret;
    }

    mpq_t ret;
    mpq_init(ret);
    integralContent_AA(poly, ret);
    RationalNumber rn(ret);
    mpq_clear(ret);
    return rn;
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::content(const std::vector<Symbol>& v) const {
    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }
	
    bool allFound = 1;
    std::vector<Symbol> matchingSyms;
    std::vector<Symbol> actualSyms = this->variables();
    for (int i = 0; i < actualSyms.size(); ++i) {
        bool found = 0;
        for (int j = 0; j < v.size(); ++j) {
            if (actualSyms[i] == v[j]) {
                found = 1;
                matchingSyms.push_back(v[j]);
                break;
            }
        }
        if (!found) {
            allFound = 0;
        }
    }
    
    // std::cerr << "\n\nGetting content: " << std::endl;
    // for (auto v : matchingSyms) {
    //     std::cerr << "matching v:" << v << std::endl;
    // }
    // for (int i = 0; i < nvar; ++i) {
    //     std::cerr << "this vars: " << names[i+1] << std::endl;
    // }
    // std::cerr << "all found: " << allFound << std::endl;

    if (allFound) {
        return this->content();
    }

    if (matchingSyms.size() == 0) {
        return *this;
    }


    SparseUnivariatePolynomial<SparseMultivariateRationalPolynomial> sup = this->convertToSUP(matchingSyms[0]);
    if (sup.numberOfTerms() <= 1 && matchingSyms.size() == 1) {
        //in this case, don't multiply by numerical content.
        //it is sufficient to return just the (recursive) coefficient in this
        //case where the sup has only one term;
        SparseMultivariateRationalPolynomial ret = sup.leadingCoefficient();
        return ret;
    }

    SparseMultivariateRationalPolynomial content = sup.content().primitivePart();
    if (content.isOne()) {
        return this->content();
    }

    for (int i = 1; i < matchingSyms.size(); ++i) {  
        sup = this->convertToSUP(matchingSyms[i]);
        SparseMultivariateRationalPolynomial temp = sup.content().primitivePart();
        content = content.gcd(temp);
        if (content.isOne()) {
            return this->content();
        }
    }

    content *= this->content();
    return content;
}


SparseMultivariateIntegerPolynomial SparseMultivariateRationalPolynomial::primitivePartSMZP() const {
    mpq_t content;
    mpq_init(content);
    AltArrZ_t* aaz = primitivePartAndContent_AAZFromAA(poly, content);
    mpq_clear(content);

    return SparseMultivariateIntegerPolynomial(aaz, nvar, names);
}

SparseMultivariateIntegerPolynomial SparseMultivariateRationalPolynomial::primitivePartSMZP(RationalNumber& content) const {
    mpq_t cont;
    mpq_init(cont);
    AltArrZ_t* aaz = primitivePartAndContent_AAZFromAA(poly, cont);
    content = RationalNumber(cont);
    mpq_clear(cont);

    return SparseMultivariateIntegerPolynomial(aaz, nvar, names);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::primitivePart() const {
    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    // std::cout << "[Ali-TEST] computing primitivePart_AA... " << std::endl;    
    AltArr_t* pp = primitivePart_AA(this->poly);
    // std::cout << "[Ali-TEST] primitivePart_AA is done... " << std::endl;

	
    return SparseMultivariateRationalPolynomial(pp, nvar, names);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::primitivePart(RationalNumber& content) const {
    if (isZero()) {
        content.zero();
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    mpq_t cont;
    mpq_init(cont);
    AltArr_t* pp = primitivePartAndContent_AA(this->poly, cont);
    content = RationalNumber(cont);
    mpq_clear(cont);

    return SparseMultivariateRationalPolynomial(pp, nvar, names);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::primitivePart(const Symbol& s) const {
    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

	std::vector<Symbol> v;
	v.push_back(s);
    return this->primitivePart(v);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::primitivePart(const std::vector<Symbol>& v) const {
    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    SparseMultivariateRationalPolynomial cont = this->content(v);
    return (*this / cont);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::primitivePart(const std::vector<Symbol>& v, SparseMultivariateRationalPolynomial& content) const {
    if (isZero()) {
        content.zero();
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    // std::cout << "[Ali-TEST] computing content(v) in PrimitivePart ... " << std::endl;    
    content = this->content(v);
    // std::cout << "[Ali-TEST] content(v) in PrimitivePart is done! ... " << std::endl;    

    return (*this / content);
}


SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::mainPrimitivePart() const {
	SparseMultivariateRationalPolynomial content;
	return mainPrimitivePart(content);
}


SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::mainPrimitivePart(SparseMultivariateRationalPolynomial& content) const {
    if (isZero()) {
        content.one();
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }
    
    AltArr_t* pPoly = primitivePart_AA (this->poly);
    AltArrZ_t* p = deepCopyPolynomial_AAZFromAA (pPoly);
    AltArrZ_t* cont = NULL;
    AltArrZ_t* res = mainPrimitiveFactorization_AAZ (p, &cont);
    
    SparseMultivariateRationalPolynomial ref (deepCopyPolynomial_AAFromAAZ (cont), nvar, names);
    
    freePolynomial_AAZ (cont);
    freePolynomial_AAZ (p);
    freePolynomial_AA (pPoly);

    content = ref;
    return SparseMultivariateRationalPolynomial(deepCopyPolynomial_AAFromAAZ (res), nvar, names);
}



////////// BPASMultivariatePolynomial ////////////////////////////////////

/**
 * Get the number of variables in this polynomial.
 */
int SparseMultivariateRationalPolynomial::numberOfVariables() const {
    if (nvar == 0 || isConstant()) {
        return 0;
    }

    degrees_t degs = 0;
    unsigned long long int* masks = getExpMaskArray(nvar);

    bool foundVar[nvar] = {0};
    foundVar[0] = ( (poly->elems[0].degs & masks[0]) > 0);
    int searchIdx = 1;
    for (int i = 0; i < poly->size && searchIdx < nvar; ++i) {
        degs = poly->elems[i].degs;
        if ( (degs & masks[searchIdx]) > 0) {
            foundVar[searchIdx] = 1;
            while (searchIdx < nvar && foundVar[searchIdx] == 1) {
                ++searchIdx;
            }
        }

        for (int j = searchIdx; j < nvar; ++j) {
            if ((degs & masks[j]) > 0) {
                foundVar[j] = 1;
            }
        }
    }

    int res = 0;
    for (int i = 0; i < nvar; ++i) {
        if (foundVar[i]) {
            ++res;
        }
    }

    free(masks);

    return res;
}


/**
 * Get the number of non-zero terms 
 */
Integer SparseMultivariateRationalPolynomial::numberOfTerms() const {
    if (poly != NULL) {
        return poly->size;
    }
    return 0;
}

/** 
 * Total degree.
 */
Integer SparseMultivariateRationalPolynomial::degree() const {
    if (isConstant()) {
        return 0;
    }
    unsigned long long int* masks = getExpMaskArray(nvar);
    int* sizes = getExpOffsetArray(nvar);

    degree_t total = 0, totalMax = 0;
    degrees_t degs;
    for (int i = 0; i < poly->size; ++i) {
        total = 0;
        degs = poly->elems[i].degs;
        for (int j = 0; j < nvar; ++j) {
            total += GET_NTH_EXP(degs, masks[j], sizes[j]);
        }
        if (total > totalMax) {
            totalMax = total;
        }
    }

    free(masks);
    free(sizes);

    return totalMax;
}

/**
 * Get the degree of a variable 
 */
Integer SparseMultivariateRationalPolynomial::degree(const Symbol& str) const {
    if (poly == NULL || nvar == 0) {
        return 0;
    }

    int strIdx = -1;
    for (int i = 1; i <= nvar; ++i) {
        if (names[i] == str) {
            strIdx = i-1;
            break;
        }
    }
    if (strIdx == -1) {
        return 0;
    }

    unsigned long long int* masks = getExpMaskArray(nvar);
    int* sizes = getExpOffsetArray(nvar);

    if (strIdx == 0) {
        //then str is the leading variable and we can just take the first
        //as we assume lexicographical order.
        degree_t d = GET_NTH_EXP(poly->elems->degs, masks[0], sizes[0]);
        
        free(masks);
        free(sizes);
        
        return d;
    } else {
        degree_t d = 0; degree_t dMax = 0;
        for (int i = 0; i < poly->size; ++i) {
            d = GET_NTH_EXP(poly->elems[i].degs, masks[strIdx], sizes[strIdx]);
            if (d > dMax) {
                dMax = d;
            }
        }

        free(masks);
        free(sizes);
        return dMax;
    }
}

/**
 * Get the leading coefficient 
 */
RationalNumber SparseMultivariateRationalPolynomial::leadingCoefficient() const {
    if (isZero()) {
        return RationalNumber(0);
    }

    return RationalNumber(poly->elems->coef);
}

RationalNumber SparseMultivariateRationalPolynomial::trailingCoefficient() const {
    if (isZero()) {
        return RationalNumber(0);
    }

    return RationalNumber(poly->elems[poly->size-1].coef);
}


/**
 * Get a coefficient, given the exponent of each variable in d.
 * v is the number of variables in d. It is assumed that the first this.nvar 
 * variables of d match the variables of this polynomial
 */
RationalNumber SparseMultivariateRationalPolynomial::coefficient(int v, const int* d) const {
    if (v < nvar) {
        std::cerr << "BPAS ERROR: SMQP calling coefficient without enough variables." << std::endl;
        exit(1);
    }
    if (isZero()) {
        return 0;
    }
    if (nvar == 0 && v == 0) {
        return RationalNumber(poly->elems->coef);
    }

    int* sizes = getExpOffsetArray(nvar);    
    degrees_t* maxExps = getMaxExpArray(nvar);

    degrees_t degs = 0;
    for (int j = 0; j < nvar; ++j) {
        if (d[j] > maxExps[j]) {
            //TODO
            std::cerr << "BPAS ERROR: SMQP exponent overflow: nvar = " << nvar << ", exp = " << d[j] << std::endl;
            exit(1);
        }
        degs |= ((degrees_t)d[j] << sizes[j]);
    }
    free(sizes);
    free(maxExps);

    RationalNumber ret(0,1);
    for (int i = 0; i < poly->size; ++i) {
        if (isEqualExponentVectors(degs, poly->elems[i].degs)) {
            ret = poly->elems[i].coef;
            break;
        }
        if (isLessExponentVectors(poly->elems[i].degs, degs)) {
            //due to ordering of terms, none will have degs as monomial.
            break;
        }
    }

    return ret;
}

/**
 * Set a coefficient, given the exponent of each variable
 */
void SparseMultivariateRationalPolynomial::setCoefficient(int v, const int* d, const RationalNumber& rn) {
    if (v != nvar) {
        std::cout << "BPAS: error, SMQP(" << nvar << "), but trying to setCoefficient with " << v << " variables." << std::endl;
        exit(1);
    }

    if (poly == NULL) {
        poly = makeConstPolynomial_AA(1, nvar, rn.get_mpq_t());
        if (nvar != 0) {
            int* sizes = getExpOffsetArray(nvar);
            degrees_t* maxExps = getMaxExpArray(nvar);
            for (int i = 0; i < v; ++i) {
                if (d[i] > maxExps[i]) {
                    std::cerr << "BPAS ERROR: SMQP exponent overflow. nvar = " << nvar << ", exp = " << d[i] << std::endl;
                    exit(1);
                }
                poly->elems->degs |= ((degrees_t) d[i] << sizes[i]);
            }
            free(sizes);
            free(maxExps);
        }
        return;
    }

    if (v == 0) {
        mpq_set(poly->elems->coef, rn.get_mpq_t());
        return;
    }

    int* sizes = getExpOffsetArray(nvar);    
    degrees_t* maxExps = getMaxExpArray(nvar);

    degrees_t degs = 0;
    for (int j = 0; j < nvar; ++j) {
        if (d[j] > maxExps[j]) {
            //TODO
            std::cerr << "BPAS ERROR: SMQP exponent overflow: nvar = " << nvar << ", exp = " << d[j] << std::endl;
            exit(1);
        }
        degs |= ((degrees_t) d[j] << sizes[j]);
    }
    free(sizes);
    free(maxExps);

    for (int i = 0; i < poly->size; ++i) {
        if (isEqualExponentVectors(poly->elems[i].degs, degs)) {
            mpq_set(poly->elems[i].coef, rn.get_mpq_t());
            return;
        }
        if (isLessExponentVectors(poly->elems[i].degs, degs)) {
            //shift everything to the right 1 and insert at i.
            if (poly->size >= poly->alloc) {
                resizePolynomial_AA(poly, poly->size + 1);
            }
            mpq_init(poly->elems[poly->size].coef);
            for (int j = poly->size; j > i; --j) {
                mpq_swap(poly->elems[j].coef, poly->elems[j-1].coef);
                poly->elems[j].degs = poly->elems[j-1].degs;
            }
            poly->elems[i].degs = degs;
            mpq_set(poly->elems[i].coef, rn.get_mpq_t());
            ++(poly->size);
            return; 
        }
    }

    //if we get here then we need to insert at the end of the array;

    if (poly->size >= poly->alloc) {
        resizePolynomial_AA(poly, poly->size + 1);
    }
    mpq_init(poly->elems[poly->size].coef);
    mpq_set(poly->elems[poly->size].coef, rn.get_mpq_t());
    poly->elems[poly->size].degs = degs;
    ++(poly->size);
} 

/**
 * Set variables' name.
 */
void SparseMultivariateRationalPolynomial::setRingVariables (const std::vector<Symbol>& xs) {
    int ns = xs.size();

    //can easily expand
    if (nvar == 0) {
        if (ns > 0) {
            delete[] names;
            names = new Symbol[ns+1];
            names[0] = "9";
            std::copy(xs.begin(), xs.end(), names+1);
            nvar = ns;
            if (poly !=NULL) {
                poly->nvar = ns;
            }
        }
        return;
    }

    if (ns == 0 && !(isZero() || isConstant())) {
        std::cerr << "BPAS ERROR: SMQP: Trying to remove all variables from a non-constant polynomial." << std::endl;
        exit(1);
    }

    //check for duplicate variable names.
    for (int i = 0; i < ns; ++i) {
        for (int j = i+1; j < ns; ++j) {
            if (xs[i] == xs[j]) {
                std::cerr << "BPAS ERROR: SMQP: Duplicate variable name in input variables for setVariableNames: " << xs[i] << " " << xs[j] << std::endl;
                exit(1); 
            }
        }
    }

    if (ns >= nvar) {
        //just a reorder or rename of vars.  

        Symbol newnames[ns+1];
        newnames[0] = "9";
        std::copy(xs.begin(), xs.end(), newnames+1);

        bool onlyRename = (ns == nvar);
        bool foundArr[nvar];
        bool usedXs[ns];
        int varmap[nvar];
        for (int i = 0; i < nvar; ++i) {
            foundArr[i] = 0;
            varmap[i] = -1;
        }
        for (int i = 0; i < ns; ++i) {
            usedXs[i] = 0;
        }

        for (int i = 0; i < nvar; ++i) {
            bool found = 0;
            for (int j = 0; j < ns; ++j) {
                if (names[i+1] == xs[j]) {
                    found = 1;
                    varmap[i] = j;
                    found = 1;
                    foundArr[i] = 1;
                    usedXs[j] = 1;
                    // newnames[j+1] = names[i+1];
                    break;
                }
            }
            if (found) {
                onlyRename = 0;
            }
        }

        if (onlyRename) {
            names[0] = "9";
            for (int i = 0; i < nvar; ++i) {
                names[i+1] = xs[i];
            }
            return;            
        }

        //at this point, foundArr holds all variable in both this and xs.
        //we need to now pair up our vars with those in xs to rename the rest.
        for (int i = 0; i < nvar; ++i) {
            if (foundArr[i]) {
                continue;
            }
            for (int j = 0; j < ns; ++j) {
                if (!usedXs[j]) {
                    varmap[i] = j;
                    usedXs[j] = 1;
                    // newnames[j+1] = xs[j];
                    break;
                }
            }
        }

        this->expandVarsInPlace(ns, newnames, varmap);
        return;

    }

    //otherwise, we are decreasing the variables of the ring
    //we must check that this is a valid operation. 
    std::vector<Symbol> nonZeros = this->variables();
    bool foundArr[nvar];
    bool usedXs[nvar];
    int varmap[nvar];
    for (int i = 0; i < nvar; ++i) {
        foundArr[i] = 0;
        varmap[i] = -1;
    }
    for (int i = 0; i < ns; ++i) {
        usedXs[i] = 0;
    }

    
    //search first for variables that much in this.names and xs.
    for (int i = 0; i < nvar; ++i) {
        for (int j = 0; j < ns; ++j) {
            if (names[i+1] == xs[j]) {
                varmap[i] = j;
                foundArr[i] = 1;
                usedXs[j] = 1;
                break;
            }
        }
    }

    //now assign, right to left, renames from this to xs.
    for (int i = 0; i < nvar; ++i) {
        if (!foundArr[i]) {
            bool set = 0;
            for (int j = 0; j < ns; ++j) {
                if (!usedXs[j]) {
                    varmap[i] = j;
                    usedXs[j] = 1;
                
                    foundArr[i] = 1;
                    break;
                }
            }
        }
    }

    //after the previous two loops we now know which variables we are to remove.
    for (int i = 0; i < nvar; ++i) {
        if (!foundArr[i]) {
            for (int j = 0; j < nonZeros.size(); ++j) {
                if (names[i+1] == nonZeros[j]) {
                    std::cerr << "BPAS ERROR: SMQP trying to remove variable " << names[i+1] << " which is non-zero in this polynomial." << std::endl;
                    exit(1);
                }
            }
        }
    }

    shrinkAndReorderVars_AA(poly, varmap, nvar);

    nvar = ns;
    delete[] names;
    names = new Symbol[nvar+1];
    names[0] = "9";
    std::copy(xs.begin(), xs.end(), names+1);
}

/**
 * Get variable names of variables with non-zero degree;
 */
std::vector<Symbol> SparseMultivariateRationalPolynomial::variables() const {
    if (nvar == 0 || isConstant()) {
        return std::vector<Symbol>();
    }

    degrees_t degs = 0;
    unsigned long long int* masks = getExpMaskArray(nvar);

    bool foundVar[nvar] = {0};
    foundVar[0] = ( (poly->elems[0].degs & masks[0]) > 0);
    int searchIdx = 1;
    for (int i = 0; i < poly->size && searchIdx < nvar; ++i) {
        degs = poly->elems[i].degs;
        if ( (degs & masks[searchIdx]) > 0) {
            foundVar[searchIdx] = 1;
            while (searchIdx < nvar && foundVar[searchIdx] == 1) {
                ++searchIdx;
            }
        }

        for (int j = searchIdx; j < nvar; ++j) {
            if ((degs & masks[j]) > 0) {
                foundVar[j] = 1;
            }
        }
    }

    std::vector<Symbol> retSyms;
    std::cerr << "nvar: " << nvar << "this: " << *this << std::endl;
    std::cerr << "variables: [";
    for (int i = 0; i < nvar; ++i) {
        if (foundVar[i]) {
            std::cerr << names[i+1] << ", ";
            retSyms.push_back(names[i+1]);
        }
    }
    std::cerr << "];" << std::endl;

    return retSyms;
}

/**
 * Get variable names of all variables available to this polynomial, 
 * even those that have zero degree.
 */
std::vector<Symbol> SparseMultivariateRationalPolynomial::ringVariables() const {
       std::cerr << "nvar: " << nvar << "this: " << *this << std::endl;
    std::cerr << "ringVariables: [";
    std::vector<Symbol> varNames;
    for (int i = 0; i < nvar; ++i) {
        varNames.push_back(names[i+1]);
        std::cerr << varNames[i] << ", ";
    }
    std::cerr << "];" << std::endl;
    return varNames;   
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::derivative(const Symbol& s, int k) const {
    if (k <= 0) {
        return *this;
    }

    if (isZero() || isConstant()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);;
    }

    int idx = -1;
    for (int i = 0; i < nvar; ++i) {
        if (s == names[i+1]) {
            idx = i;
            break;
        }
    }

    if (idx == -1) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    AltArr_t* temp = derivative_AA(poly, idx, k);
    return SparseMultivariateRationalPolynomial(temp, nvar, names);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::integral(const Symbol& s, int k) const {
    if (k <= 0) {
        return *this;
    }

    int idx = -1;
    for (int i = 0; i < nvar; ++i) {
        if (s == names[i+1]) {
            idx = i;
            break;
        }
    }

    if (idx == -1) {
        Symbol newnames[nvar+2];
        newnames[0] = "9";
        newnames[1] = s;
        for (int j = 1; j < nvar+1; ++j) {
            newnames[j+1] = names[j];
        }
        AltArr_t* temp = integral_AA(poly, idx, k);
        return SparseMultivariateRationalPolynomial(temp, nvar+1, newnames);
    }

    AltArr_t* temp = integral_AA(poly, idx, k);
    return SparseMultivariateRationalPolynomial(temp, nvar, names);
}


////////// RecursivelyViewedPolynomial  ////////////////////////////////////

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::initial() const {
    if (nvar == 0 || isConstant() || isZero()) {
        return *this;
    }  
    return leadingCoefficientInVariable(leadingVariable());
}

int SparseMultivariateRationalPolynomial::mainDegree() const {
    if (isZero() || isConstant()) {
        return 0;
    }

    unsigned long long int* masks = getExpMaskArray(nvar);
    int* sizes = getExpOffsetArray(nvar); 

    int ret = 0;
    for (int j = 0; j < nvar; ++j) {
        if ((poly->elems->degs & masks[j]) != 0) {
            ret = GET_NTH_EXP(poly->elems->degs, masks[j], sizes[j]);
            break;
        }
    }

    free(masks);
    free(sizes);
    return ret;
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::rank() const {
    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    } 

    if (isConstant()) {
        SparseMultivariateRationalPolynomial ret(NULL, nvar, names);
        ret.one();

        return ret;
    }

    Symbol lv("");
    int lvIdx = -1;
    unsigned long long int* masks = getExpMaskArray(nvar);
    for (int i = 0; i < nvar; ++i) {
        if ((poly->elems->degs & masks[i]) != 0) {
            lv = names[i+1];
            lvIdx = i;
            break;
        }
    }

    free(masks);

    SparseMultivariateRationalPolynomial ret(lv);
    ret.poly->elems->degs = this->mainDegree();

    return ret;
}


SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::head() const {
    if (nvar == 0 || isZero() || isConstant()) {
        return *this;
    }

    int* sizes = getExpOffsetArray(nvar);
    unsigned long long int* masks = getExpMaskArray(nvar);

    Symbol leadVar;
    int k = 0;
    int kdeg = 0;
    degrees_t packedDeg = 0;
    for (int i = 0; i < nvar; ++i) {
        if ((poly->elems->degs & masks[i]) != 0) {
            leadVar = names[i+1];
            k = i;
            packedDeg = poly->elems->degs & masks[i];
            kdeg = GET_NTH_EXP(poly->elems->degs, masks[i], sizes[i]);
            break;
        }
    }

    AltArr_t* ret = makePolynomial_AA(10, nvar);
    for (int i = 0; i < poly->size; ++i) {
        if ((poly->elems[i].degs & masks[k]) != packedDeg) {
            break;
        }

        if (ret->size >= ret->alloc) {
            resizePolynomial_AA(ret, ret->size + 10);
        }

        ret->elems[ret->size].degs = poly->elems[i].degs;
        mpq_init(ret->elems[ret->size].coef);
        mpq_set(ret->elems[ret->size].coef, poly->elems[i].coef);
        ++(ret->size);
    }

    free(sizes);
    free(masks);
    return SparseMultivariateRationalPolynomial(ret, nvar, names);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::tail() const {
     if (nvar == 0 || isZero() || isConstant()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    int* sizes = getExpOffsetArray(nvar);
    unsigned long long int* masks = getExpMaskArray(nvar);

    Symbol leadVar;
    int k = 0;
    int kdeg = 0;
    degrees_t packedDeg = 0;
    for (int i = 0; i < nvar; ++i) {
        if ((poly->elems->degs & masks[i]) != 0) {
            leadVar = names[i+1];
            k = i;
            packedDeg = poly->elems->degs & masks[i];
            kdeg = GET_NTH_EXP(poly->elems->degs, masks[i], sizes[i]);
            break;
        }
    }

    AltArr_t* ret = makePolynomial_AA(poly->size, nvar);
    for (int i = 0; i < poly->size; ++i) {
        if ((poly->elems[i].degs & masks[k]) == packedDeg) {
            continue;
        }

        ret->elems[ret->size].degs = poly->elems[i].degs;
        mpq_init(ret->elems[ret->size].coef);
        mpq_set(ret->elems[ret->size].coef, poly->elems[i].coef);
        ++(ret->size);
    }

    free(sizes);
    free(masks);
    return SparseMultivariateRationalPolynomial(ret, nvar, names);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::separant() const {
    std::cerr << "BPAS ERROR: SparseMultivariateRationalPolynomial::separant NOT YET IMPLEMENTED" << std::endl;
    return *this;
}



////////// SMQP-Specific ////////////////////////////////////

bool SparseMultivariateRationalPolynomial::isEqual(const SparseMultivariateRationalPolynomial& b) const {
    if (isZero()) {
        if (b.isZero()) {
            return 1;
        } else {
            return 0;
        }
    }
    if (b.isZero()) {
        return 0;
    }
    if (isConstant()) {
        if (b.isConstant()) {
            mpq_class tempa(poly->elems->coef);
            mpq_class tempb(b.poly->elems->coef);
            return tempa == tempb;
        } else {
            return 0;
        }
    }
    if (poly->size != b.poly->size) {
        return 0;
    }

    std::vector<int> xs;
    bool isOrdered = isOrderedRing(b, xs);
    if (!isOrdered) { return 0; }

    int v = xs.size() / 2;

    degrees_t* aMasks = getExpMaskArray(nvar);
    degrees_t* bMasks = getExpMaskArray(b.nvar);

    int* aSizes = getExpOffsetArray(nvar);
    int* bSizes = getExpOffsetArray(b.nvar);
    
    int ret = 1;
    degree_t adeg, bdeg;
    for (int i = 0; i < poly->size; ++ i){
        if (mpq_cmp(poly->elems[i].coef, b.poly->elems[i].coef) != 0) {
            ret = 0;
            break;
        }
        for (int j = 0; j < v; ++j) {
            adeg = GET_NTH_EXP(poly->elems[i].degs, aMasks[xs[2*j]-1], aSizes[xs[2*j]-1]);
            bdeg = GET_NTH_EXP(b.poly->elems[i].degs, bMasks[xs[2*j+1]-1], bSizes[xs[2*j+1]-1]);
            if (xs[2*j] && xs[2*j+1] && (adeg != bdeg)) {
                ret = 0;
                break;
            } else if (!xs[2*j] && xs[2*j+1] && (bdeg != 0) ) {
                ret = 0;
                break;
            } else if (xs[2*j] && !xs[2*j+1] && (adeg != 0) ) {
                ret = 0;
                break;
            }
        }
        
    }

    free(aMasks);
    free(aSizes);
    free(bMasks);
    free(bSizes);

    return ret;
}

/**
 * Evaluate *this polynomial given the variables and their values in vars, and values.
 * vars must be a list of variables which are a (not necessarily proper) subset.
 * vars and values should have matching indices. i.e. the values of vars[i] is values[i].
 *
 * returns a new SMQP where all variables in vars have been evaluated using the values given. 
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::evaluate(const std::vector<Symbol>& vars, const std::vector<RationalNumber>& values) const {

    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }
    if (isConstant()) {
        return SparseMultivariateRationalPolynomial(*this);
    }

    if (vars.size() != values.size()) {
        std::cerr << "BPAS: SMQP: ERROR number of variables does not much number of points in evaluate." << std::endl;
        exit(1);
    }

    if (nvar == 1) {
        if (names[1] != vars[0]) {
            std::cerr << "BPAS: SMQP: error: trying to evaluate variable that does not exist in this SMQP: " << vars[0] << std::endl;
            exit(1);
        }

        mpq_t res;
        mpq_init(res);
        univarEvaluate_AA(poly, values[0].get_mpq_t(), res);
        RationalNumber r(res);
        SparseMultivariateRationalPolynomial ret(r);
        mpq_clear(res);
        return ret;
    }

    int active[nvar];
    mpq_t vals[nvar];
    for (int i = 0; i < nvar; ++i) {
        active[i] = 0;
        mpq_init(vals[i]);
    }

    int newNvar = nvar;
    for (int i = 0; i < vars.size(); ++i) {
        bool found = 0;
        for (int j = 0; j < nvar; ++j) {
            if (names[j+1] == vars[i]) {
                found = 1;

                --newNvar;    
                active[j] = 1;
                mpq_set(vals[j], values[i].get_mpq_ref().get_mpq_t());
            }
        }
        if (!found) {
            std::cerr << "BPAS: SMQP: error: trying to evaluate variable that does not exist in this SMQP: " << vars[i] << std::endl;
            exit(1);
        }
    }

    Symbol newnames[newNvar+1];
    if (newNvar == 0) { 
        newnames[0] = "1";
    } else {
        newnames[0] = names[0];
        int idx = 1;
        for(int i = 0; i < nvar; ++i) {
            if (!active[i]) {
                newnames[idx] = names[i+1];
                ++idx;
            }
        }
    }

    AltArr_t* evalPoly = evaluatePoly_AA(poly, active, vals, nvar);
    return SparseMultivariateRationalPolynomial(evalPoly, newNvar, newnames);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::interpolate(const std::vector<std::vector<RationalNumber>>& points, const std::vector<RationalNumber>& vals) {
    if (points.size() != vals.size()) {
        std::cerr << "BPAS ERROR: SMQP: In interpolation, number of points does not match number of values." << std::endl;
        exit(1);
    }
    if (points.size() == 0) {
        return 0;
    }

    if (points[0].size() == 1) {
        mpq_t mpqPoints[points.size()];
        mpq_t mpqVals[points.size()];
        for (int i = 0; i < points.size(); ++i) {
            mpq_init(mpqPoints[i]);
            mpq_init(mpqVals[i]);
            mpq_set(mpqPoints[i], points[i][0].get_mpq_t());
            mpq_set(mpqVals[i], vals[i].get_mpq_t());
        }

        AltArr_t* interp = univarInterpolate_AA(mpqPoints, mpqVals, points.size());

        for (int i = 0; i < points.size(); ++i) {
            mpq_clear(mpqPoints[i]);
            mpq_clear(mpqVals[i]);
        }

        SparseMultivariateRationalPolynomial ret(1);
        ret.poly = interp;
        return ret;
    }

    std::cerr << "BPAS SMQP: interpolate(points, vals) NOT YET IMPLEMENTED" << std::endl;
    return 0;
}


/**
 * Divide this by polynomial b, returning the quotient and remainder in q and r, respectively.
 *
 * returns a boolean indicating if the division was exact.
 */
bool SparseMultivariateRationalPolynomial::divide(const SparseMultivariateRationalPolynomial& b, SparseMultivariateRationalPolynomial& q, SparseMultivariateRationalPolynomial& r) const {
    if (b.isZero()) {
        std::cout << "BPAS: error, dividend is zero from SMQP." << std::endl;
        exit(1);
    }

    if (b.isConstant()) {
        q = *this / b.poly->elems->coef;
        r = SparseMultivariateRationalPolynomial(NULL, nvar, names);
        return true;
    }
    if (isConstant()) {
        q = SparseMultivariateRationalPolynomial(NULL, nvar, names);
        r = *this;
        return false;
    }

    std::vector<int> xs;
    bool isOrdered = isOrderedRing(b, xs);

    if (!isOrdered) {
        std::cout << "BPAS: error, trying to divide between Q[";
        for (int i = 1; i <= nvar; ++i) {
            std::cout << names[i];
            if (i < nvar) { std::cout << ", "; }
        }
        std::cout << "] and Q[";
        for (int i = 1; i <= b.nvar; ++i) {
            std::cout << b.names[i];
            if (i < b.nvar) { std::cout << ", "; }
        }
        std::cout << "]." << std::endl;
        exit(1);
    }

    int superNvar = xs.size() / 2;
    if (superNvar != nvar || superNvar != b.nvar) {
        //map indices to the expanded superset. 
        int varmap[nvar];
        int bvarmap[b.nvar];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                varmap[xs[i]-1] = i/2;
            }
            if (xs[i+1] != 0) {
                bvarmap[xs[i+1]-1] = i/2;
            }
        }

        //create new combined names array
        Symbol newnames[superNvar+1];
        //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
        newnames[0] = this->names[0];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                newnames[(i/2) + 1] = names[xs[i]];
            } else {
                newnames[(i/2) + 1] = b.names[xs[i+1]];
            }
        }

        // std::cerr << "newnames: "  << std::endl;
        // for (auto v : newnames) {
        //     std::cerr << "v: " << v << std::endl;
        // }

        // for (int i = 0; i < superNvar; ++i) {
        //     std::cerr << "avarmap[" << i << "]: " << varmap[i] << std::endl;
        // }
        // for (int i = 0; i < superNvar; ++i) {
        //     std::cerr << "bvarmap[" << i << "]: " << bvarmap[i] << std::endl;
        // }
        // std::cerr << std::endl;

        SparseMultivariateRationalPolynomial tempc = this->expandVariables(superNvar, newnames, varmap);
        SparseMultivariateRationalPolynomial tempb = b.expandVariables(superNvar, newnames, bvarmap);

        AltArr_t* qAA = NULL, * rAA = NULL;
        dividePolynomials_AA(tempc.poly, tempb.poly, &qAA, &rAA, superNvar);

        q = SparseMultivariateRationalPolynomial(qAA, superNvar, newnames);
        r = SparseMultivariateRationalPolynomial(rAA, superNvar, newnames);

        return (rAA == NULL || rAA->size == 0);

    } else {

        // std::cerr << "divide on same ring" << std::endl;

        AltArr_t* qAA = NULL, * rAA = NULL;
        dividePolynomials_AA(this->poly, b.poly, &qAA, &rAA, nvar);
        q = SparseMultivariateRationalPolynomial(qAA, nvar, names);
        r = SparseMultivariateRationalPolynomial(rAA, nvar, names);
        return (rAA == NULL || rAA->size == 0);
    }    
}

/**
 * Get the remainder of *this divided by b.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator% (const SparseMultivariateRationalPolynomial& b) const {
    SparseMultivariateRationalPolynomial q,r;
    this->divide(b, q, r);
    return r;
}

/**
 * Update *this by setting it to the remainder of *this divided by b.
 */ 
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator%= (const SparseMultivariateRationalPolynomial& b) {
    *this = (*this % b);
    return *this;
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::pseudoDivide(const SparseMultivariateRationalPolynomial& b, SparseMultivariateRationalPolynomial* quo, SparseMultivariateRationalPolynomial* mult, bool lazy) const {
    if (b.isZero()) {
        std::cerr << "BPAS: error, pseudo-dividend is zero from SMQP." << std::endl;
        exit(1);
    }
    if (b.isConstant()) {
        std::cerr << "BPAS: error, pseudo-dividend is a constant in SMQP." << std::endl;
        exit(1);
    }

    if (isZero()) {
        if (quo != NULL) {
            (*quo).zero();
        }
        if (mult != NULL) {
            (*mult).one();
        }
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    //This will also capture case when nvar = 0 for both.
    if (b.isConstant() && isConstant()) {
        if (quo != NULL) {
            *quo = *this;
        }
        if (mult != NULL) {
            *mult = b;
        }
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    std::vector<int> xs;
    bool isOrdered = isOrderedRing(b, xs);

    if (!isOrdered) {
        std::cout << "BPAS: error, trying to pseudo divide between Q[";
        for (int i = 1; i <= nvar; ++i) {
            std::cout << names[i];
            if (i < nvar) { std::cout << ", "; }
        }
        std::cout << "] and Q[";
        for (int i = 1; i <= b.nvar; ++i) {
            std::cout << b.names[i];
            if (i < b.nvar) { std::cout << ", "; }
        }
        std::cout << "]." << std::endl;
        exit(1);
    }

    SparseMultivariateRationalPolynomial q, r;

    int superNvar = xs.size() / 2;
    if (superNvar != nvar || superNvar != b.nvar) {
        //map indices to the expanded superset. 
        int varmap[nvar];
        int bvarmap[b.nvar];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                varmap[xs[i]-1] = i/2;
            }
            if (xs[i+1] != 0) {
                bvarmap[xs[i+1]-1] = i/2;
            }
        }

        //create new combined names array
        Symbol newnames[superNvar+1];
        //isOrderedRing returns false if this.names[0] != b.names[0], therefore safe
        newnames[0] = this->names[0];
        for (int i = 0; i < xs.size(); i += 2) {
            if (xs[i] != 0) {
                newnames[(i/2) + 1] = names[xs[i]];
            } else {
                newnames[(i/2) + 1] = b.names[xs[i+1]];
            }
        }

        SparseMultivariateRationalPolynomial tempc = this->expandVariables(superNvar, newnames, varmap);
        SparseMultivariateRationalPolynomial tempb = b.expandVariables(superNvar, newnames, bvarmap);

        //Now that we have expanded this and B to live in the same ring, we need
        //to if the main variable of b is the same as c.

        Symbol leadVar = tempb.leadingVariable();
        if (leadVar != tempb.names[1]) {
            //need to rearrange *this to have same leading var and then convert to rec form.
            Symbol newvars[superNvar+1];
            newvars[0] = tempb.names[0];
            int reorderVarmap[superNvar];
            int before = 1;
            for (int i = 0; i < superNvar; ++i) {
                if (tempb.names[i+1] == leadVar) {
                    before = 0;
                    newvars[1] = leadVar;
                    reorderVarmap[i] = 0;
                    //leadVar already in newvars
                    continue;
                }

                //direct map for vars after leadVar, otherwise shift up by 1. 
                newvars[i+1+before] = tempb.names[i+1];
                reorderVarmap[i] = i+before;
            }

            int invVarmap[superNvar];
            for (int i = 0; i < superNvar; ++i) {
                invVarmap[reorderVarmap[i]] = i;
            }            

            tempc.reorderVarsInPlace(reorderVarmap);
            tempb.reorderVarsInPlace(reorderVarmap);

            AltArr_t* cAA = tempc.poly;
            AltArr_t* bAA = tempb.poly;

            RecArr_t* recC = convertToRecursiveArray(cAA);
            RecArr_t* recB = convertToRecursiveArray(bAA);

            AltArr_t* qAA = NULL, * rAA = NULL;
            AltArr_t* hPow = NULL;
            int e = 0;
            pesudoDivide_RecArray(recC, recB, &qAA, &rAA, &e, &hPow, superNvar, lazy);
            cAA = convertFromRecursiveArray(recC, superNvar);
            bAA = convertFromRecursiveArray(recB, superNvar);
            tempc.poly = cAA;
            tempb.poly = bAA;

            q = SparseMultivariateRationalPolynomial(qAA, superNvar, newvars);
            r = SparseMultivariateRationalPolynomial(rAA, superNvar, newvars);
            q.reorderVarsInPlace(invVarmap);
            r.reorderVarsInPlace(invVarmap);

            SparseMultivariateRationalPolynomial smqpHPow(hPow, superNvar, newvars);
            smqpHPow.reorderVarsInPlace(invVarmap);
            if (quo != NULL) {
                *quo = q;
            }
            if (mult != NULL) {
                *mult = smqpHPow;
            }
            return r;
        }

        AltArr_t* cAA = tempc.poly;
        AltArr_t* bAA = tempb.poly;
        RecArr_t* recC = convertToRecursiveArray(cAA);
        RecArr_t* recB = convertToRecursiveArray(bAA);

        AltArr_t* qAA = NULL, * rAA = NULL;
        AltArr_t* hPow = NULL;
        int e = 0;
        pesudoDivide_RecArray(recC, recB, &qAA, &rAA, &e, &hPow, superNvar, lazy);
        cAA = convertFromRecursiveArray(recC, superNvar);
        bAA = convertFromRecursiveArray(recB, superNvar);
        tempc.poly = cAA;
        tempb.poly = bAA;

        q = SparseMultivariateRationalPolynomial(qAA, superNvar, newnames);
        r = SparseMultivariateRationalPolynomial(rAA, superNvar, newnames);
        SparseMultivariateRationalPolynomial smqpHPow(hPow, superNvar, newnames);
        if (quo != NULL) {
            *quo = q;
        }
        if (mult != NULL) {
            *mult = smqpHPow;
        }
        return r;

    } else {
        //in this case, this and b have same variables in same order.

        Symbol leadVar = b.leadingVariable();
        if (leadVar != b.names[1]) {

            //need to rearrange *this to have same leading var and then convert to rec form.
            Symbol newvars[nvar+1];
            newvars[0] = b.names[0];
            int varmap[nvar];
            int before = 1;
            for (int i = 0; i < nvar; ++i) {
                if (b.names[i+1] == leadVar) {
                    before = 0;
                    newvars[1] = leadVar;
                    varmap[i] = 0;
                    //leadVar already in newvars
                    continue;
                }

                //direct map for vars after leadVar, otherwise shift up by 1. 
                newvars[i+1+before] = b.names[i+1];
                varmap[i] = i+before;
            }

            int invVarmap[nvar];
            for (int i = 0; i < nvar; ++i) {
                invVarmap[varmap[i]] = i;
            }
            SparseMultivariateRationalPolynomial cReordered = this->expandVariables(nvar, newvars, varmap);
            SparseMultivariateRationalPolynomial bReordered = b.expandVariables(nvar, newvars, varmap);

            AltArr_t* cAA = cReordered.poly;
            AltArr_t* bAA = bReordered.poly;
            RecArr_t* recC = convertToRecursiveArray(cAA);
            RecArr_t* recB = convertToRecursiveArray(bAA);

            AltArr_t* qAA = NULL, * rAA = NULL;
            AltArr_t* hPow = NULL;
            int e = 0;
            pesudoDivide_RecArray(recC, recB, &qAA, &rAA, &e, &hPow, superNvar, lazy);
            cReordered.poly = cAA = convertFromRecursiveArray(recC, nvar);
            bReordered.poly = bAA = convertFromRecursiveArray(recB, nvar);
            
            q = SparseMultivariateRationalPolynomial(qAA, nvar, newvars);
            r = SparseMultivariateRationalPolynomial(rAA, nvar, newvars);

            q.reorderVarsInPlace(invVarmap);
            r.reorderVarsInPlace(invVarmap);

            SparseMultivariateRationalPolynomial smqpHPow(hPow, superNvar, newvars);
            smqpHPow.reorderVarsInPlace(invVarmap);
            if (quo != NULL) {
                *quo = q;
            }
            if (mult != NULL) {
               *mult = smqpHPow;
           }
           return r;
       }  

       // if (nvar == 1 && b.nvar == 1) {
       //     AltArr_t* qAA = NULL, *rAA = NULL;
       //     int e = 0;
       //     univariatePseudoDividePolynomials_AA(this->poly, b.poly, &qAA, &rAA, &e, lazy);
           
       //     if (quo != NULL) {
       //         *quo = SparseMultivariateRationalPolynomial(qAA, nvar, names);
       //     }

       //     if (mult != NULL) {
       //          RationalNumber h(b.poly->elems->coef);
       //          h ^= e;
       //          *mult = h;                
       //      }
       //      return SparseMultivariateRationalPolynomial(rAA, nvar, names);
       //  }

        AltArr_t* cAA = NULL; //(this->poly);
        AltArr_t* bAA = b.poly;
        RecArr_t* recC = convertToRecursiveArray(poly);
        RecArr_t* recB = convertToRecursiveArray(bAA);

        AltArr_t* qAA = NULL, *rAA = NULL;
        AltArr_t* hPow = NULL;
        int e = 0;
        pesudoDivide_RecArray(recC, recB, &qAA, &rAA, &e, &hPow, superNvar, lazy);

        poly = convertFromRecursiveArray(recC, superNvar);
        bAA = convertFromRecursiveArray(recB, superNvar);

        q = SparseMultivariateRationalPolynomial(qAA, superNvar, names);
        r = SparseMultivariateRationalPolynomial(rAA, superNvar, names);

        SparseMultivariateRationalPolynomial smqpHPow(hPow, superNvar, names);
        if (quo != NULL) {
            *quo = q;
        }
        if (mult != NULL) {
            *mult = smqpHPow;
        }

        return r;
    }    
}



/**
 * Add *this and a ratNum_t.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator+ (const RationalNumber& c) const {
    SparseMultivariateRationalPolynomial ret = *this;

    if (isZero()) {
        if (ret.poly != NULL) {
            freePolynomial_AA(ret.poly);
        }
        ret.poly = makeConstPolynomial_AA(1, ret.nvar, c.get_mpq_t());
        return ret;
    }

    if (isZeroExponentVector(ret.poly->elems[ret.poly->size-1].degs)) {
        mpq_add(ret.poly->elems[ret.poly->size-1].coef, ret.poly->elems[ret.poly->size-1].coef, c.get_mpq_t());
        return ret;
    } 

    if (ret.poly->size >= ret.poly->alloc) {
        resizePolynomial_AA(ret.poly, ret.poly->alloc+10);
    }

    mpq_init(ret.poly->elems[ret,poly->size].coef);
    mpq_set(ret.poly->elems[ret.poly->size].coef, c.get_mpq_t());
    ret.poly->elems[ret.poly->size].degs = 0;
    ++(ret.poly->size);

    return ret;
}


/**
 * Update *this by adding r
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator+= (const RationalNumber& c) {    
    slp.clear();

    if (isZero()) {
        if (poly != NULL) {
            freePolynomial_AA(poly);
        }
        poly = makeConstPolynomial_AA(1, nvar, c.get_mpq_t());
        return *this;
    }

    if (isZeroExponentVector(poly->elems[poly->size-1].degs)) {
        mpq_add(poly->elems[poly->size-1].coef, poly->elems[poly->size-1].coef, c.get_mpq_t());
        return *this;
    } 

    if (poly->size >= poly->alloc) {
        resizePolynomial_AA(poly, poly->alloc+10);
    }

    mpq_init(poly->elems[poly->size].coef);
    mpq_set(poly->elems[poly->size].coef, c.get_mpq_t());
    poly->elems[poly->size].degs = 0;
    ++(poly->size);


    return *this;
}

/**
 * Subtract the ratNum_t r from *this.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator- (const RationalNumber& c) const {
    RationalNumber negC = -c;
    return *this + negC;
}

/**
 * Update *this by subtracting ratNum_t r.
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator-= (const RationalNumber& c) {
    RationalNumber negC = -c;
    return *this += negC;
}

/**
 * Multiply *this by ratNum_t r.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator* (const RationalNumber& c) const {
    if (c == 0 || isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    SparseMultivariateRationalPolynomial ret = *this;

    if (c == 1) {
        return ret;
    }

    mpq_t mult;
    mpq_init(mult);
    mpq_set(mult, c.get_mpq_t());
    for(int i = 0; i < ret.poly->size; ++i) {
        mpq_mul(ret.poly->elems[i].coef, ret.poly->elems[i].coef, mult);
    }
    mpq_clear(mult);

    return ret;
}

/**
 * Update *this by multiplying by ratNum_t r.
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator*= (const RationalNumber& c) {
    slp.clear();
    if (isZero()) {
        return *this;
    }
    if (c == 0) {
        freePolynomial_AA(poly);
        poly = NULL;
        return *this;
    }
    if (c == 1) {
        return *this;
    }

    mpq_t mult;
    mpq_init(mult);
    mpq_set(mult, c.get_mpq_t());
    for(int i = 0; i < poly->size; ++i) {
        mpq_mul(poly->elems[i].coef, poly->elems[i].coef, mult);
    }
    mpq_clear(mult);

    return *this;
}

/**
 * Divide *this by ratNum_t r.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator/ (const RationalNumber& c) const {
    if (c == 0) {
        std::cout << "BPAS: error, dividend is zero from SMQP." << std::endl;
        exit(1);
    }

    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    if (c == 1) {
        return SparseMultivariateRationalPolynomial(*this);
    }
    
    ratNum_t rInv;
    mpq_init(rInv);
    mpq_inv(rInv, c.get_mpq_t());
    SparseMultivariateRationalPolynomial ret = (*this * rInv);
    mpq_clear(rInv);
    return ret;
}

/**
 * Divide ratNum_t r by SMQP b.
 */
SparseMultivariateRationalPolynomial operator/ (const ratNum_t& r, const SparseMultivariateRationalPolynomial& b) {
    if (b.isConstant()) {
        if (mpq_sgn(b.poly->elems->coef) == 0) {
            std::cout << "BPAS: error, dividend is zero from SMQP." << std::endl;
            exit(1);
        }
        AltArr_t* rPoly = makeConstPolynomial_AA(1, b.nvar, r);
        mpq_div(rPoly->elems->coef, r, b.poly->elems->coef);
        return SparseMultivariateRationalPolynomial(rPoly, b.nvar, b.names);
    } else {
        std::cerr << "BPAS ERROR: SMQP non-exact division in mpq_t / SparseMultivariateRationalPolynomial" << std::endl;
        exit(1);
    }
}

/** 
 * Update *this by dividing by ratNum_t r.
 */
SparseMultivariateRationalPolynomial& SparseMultivariateRationalPolynomial::operator/= (const RationalNumber& c) {
    *this = *this / c;
}


/**
 * Get the polynomial term at index. Returns 0 if index is beyond the 
 * number of terms in this polynomial.
 */
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::operator[] (int index) const {
    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    if (index < poly->size) {
        AltArr_t* temp = makePolynomial_AA(1, nvar);
        mpq_init(temp->elems->coef);
        mpq_set(temp->elems->coef, poly->elems[index].coef);
        temp->elems->degs = poly->elems[index].degs;
        temp->size = 1;
        return SparseMultivariateRationalPolynomial(temp, nvar, names);
    }

    return SparseMultivariateRationalPolynomial(NULL, nvar, names);
}


/**
 * Get the leading variable, that is, the highest-order variable with positive degree
 * of this polynomial. 
 * returns the leading variable or the empty string if this polynomial has zero variables.
 */
Symbol SparseMultivariateRationalPolynomial::leadingVariable() const {
    if (nvar == 0 || isConstant()) {
        return Symbol("");
    }

    Symbol ret("");
    unsigned long long int* masks = getExpMaskArray(nvar);
    for (int i = 0; i < nvar; ++i) {
        if ((poly->elems->degs & masks[i]) != 0) {
            ret = names[i+1];
            break;
        }
    }

    free(masks);
    return ret;
}

/**
 * Get the degree of this polynomial w.r.t the leading variable.
 */
Integer SparseMultivariateRationalPolynomial::leadingVariableDegree() const {
    if (nvar == 0 || isConstant()) {
        return 0;
    }

    unsigned long long int* masks = getExpMaskArray(nvar);
    int* sizes = getExpOffsetArray(nvar);

    degree_t exp = 0;
    for (int i = 0; i < nvar; ++i) {
        if (GET_NTH_EXP(poly->elems->degs, masks[i], sizes[i]) != 0) {
            exp = GET_NTH_EXP(poly->elems->degs, masks[i], sizes[i]);
            break;
        }
    }

    free(masks);
    free(sizes);
    return exp;
}

/**
 * Is the contant term zero.
 */
bool SparseMultivariateRationalPolynomial::isConstantTermZero() const {
    if (isZero()) {
        return 1;
    }

    return !isZeroExponentVector(poly->elems[poly->size-1].degs);
}

SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::leadingCoefficientInVariable (const Symbol& x, int* e) const {
    int deg = 0;
    if (e != NULL) {
        *e = 0;
    }
    if (isZero()){
	return *this;
    }
    
    int k = 0;
    for (int i = 1; i <= nvar; ++i) {
        if (names[i] == x) {
            k = i;
            break;
        }
    }
    if (k == 0) {
        //If supplied variable is not one of our variables, then really all of *this
        //is leading coeff w.r.t input Symbol x.
        return *this;
    }

    int v = nvar - 1;
    SparseMultivariateRationalPolynomial r(v);
    for (int i = 0; i < k; ++i) {
        r.names[i] = names[i];
    }
    for (int i = k; i < v+1; ++i) {
        r.names[i] = names[i+1];
    }

    if (isConstant()) {
        r.poly = makeConstPolynomial_AA(1, nvar, poly->elems->coef);
        return r;
    }
    
    --k; //recall names index is +1 of degs index


    unsigned long long int* masks = getExpMaskArray(nvar);
    int* sizes = getExpOffsetArray(nvar);
    unsigned long long int masksK = masks[k];
    int sizesK = sizes[k];
    free(masks);
    free(sizes);

    AltArr_t* rPoly = NULL;
    degrees_t packedDeg = 0, newDeg = 0;
    for (int i = 0; i < poly->size; ++i) {
        if (compareExponentVectors( (poly->elems[i].degs & masksK) , packedDeg) >= 0) {
            if (isGreaterExponentVectors( (poly->elems[i].degs & masksK) , packedDeg)) {
                packedDeg = poly->elems[i].degs & masksK;
                deg = packedDeg >> sizesK;
                freePolynomial_AA(rPoly);
                rPoly = NULL;
            }
            newDeg = poly->elems[i].degs & (~masksK);
            if (rPoly == NULL) {
                rPoly = makePolynomial_AA(10, nvar);
            } else if (rPoly->alloc <= rPoly->size) {
                resizePolynomial_AA(rPoly, rPoly->size * 2);
            }
            mpq_init(rPoly->elems[rPoly->size].coef);
            mpq_set(rPoly->elems[rPoly->size].coef, poly->elems[i].coef);
            rPoly->elems[rPoly->size].degs = newDeg;
            ++(rPoly->size);
        }
    }

    //we have consturcted a polynomial in v+1 vars but we want v vars, so re-pack each degs.
    shrinkNumVarsAtIdx_AA(rPoly, k);

    //probably not needed
    mergeSortPolynomial_AA(rPoly);

    r.poly = rPoly;

    if (e != NULL) {
        *e = deg;
    }
    return r;
}

/**
 * Convert to a SUP<SMQP> given the variable 'x'.
 *
 * returns the SUP<SMQP>.
 */
SparseUnivariatePolynomial<SparseMultivariateRationalPolynomial> SparseMultivariateRationalPolynomial::convertToSUP(const Symbol& x) const {
    SparseUnivariatePolynomial<SparseMultivariateRationalPolynomial> r;
    r.setVariableName(x); 

    int k = 0;
    for (int i = 1; i <= nvar; ++i) {
        if (names[i] == x) {
            k = i;
            break;
        }
    }

    if (k == 0) {
        r.setCoefficient(0, *this);
        return r;
    }

    if (nvar == 1) {
        for (int i = 0; i < poly->size; ++i) {
            SparseMultivariateRationalPolynomial coef(RationalNumber(poly->elems[i].coef), 0);
            r.setCoefficient(poly->elems[i].degs, coef);
        }
        return r;
    }

    int v = nvar - 1;
    int d = this->degree(x).get_si();

    std::vector<SparseMultivariateRationalPolynomial> mpolys(d+1, SparseMultivariateRationalPolynomial(v));
    
    Symbol newnames[v+1];
    for (int i = 0; i < k; ++i) {
        newnames[i] = names[i];
    }
    for (int i = k; i < v+1; ++i) {
        newnames[i] = names[i+1];
    }
    //setup names and nvar of each of the polys
    for (int i = 0; i <= d; ++i) {
        std::copy(newnames, newnames+v+1, mpolys[i].names);
    }

    unsigned long long int* masks = getExpMaskArray(nvar);
    int* sizes = getExpOffsetArray(nvar);

    bool isLeadVar = (this->leadingVariable() == names[k]);
    --k;

    degrees_t curDegs;
    degree_t curD;
    for (int i = 0; i < poly->size; ++i) {
        curD = GET_NTH_EXP(poly->elems[i].degs, masks[k], sizes[k]);
        if (mpolys[curD].poly == NULL) {
            mpolys[curD].poly = makePolynomial_AA(10, nvar);
        }
        if (mpolys[curD].poly->alloc <= mpolys[curD].poly->size) {
            resizePolynomial_AA(mpolys[curD].poly, mpolys[curD].poly->size * 2);
        }
        mpq_init(mpolys[curD].poly->elems[mpolys[curD].poly->size].coef);
        mpq_set(mpolys[curD].poly->elems[mpolys[curD].poly->size].coef, poly->elems[i].coef);
        mpolys[curD].poly->elems[mpolys[curD].poly->size].degs = poly->elems[i].degs & (~masks[k]);
        ++(mpolys[curD].poly->size);
    }
    
    for (int i = 0; i <= d; ++i) {
        if (mpolys[i].isZero()) {
            continue;
        }
        shrinkNumVarsAtIdx_AA(mpolys[i].poly, k);
        if (!(k == 0 || isLeadVar)) {
            mergeSortPolynomial_AA(mpolys[i].poly);
        }
        r.setCoefficient(i, mpolys[i]);
    }

    free(masks);
    free(sizes);

    return r;
}


/**
 * Negate all the coefficients of *this. Note, that due to the 
 * sharing nature of underling nodes, this may alter the Nodes of
 * other SMQP.
 */
void SparseMultivariateRationalPolynomial::negate() {
    if (isZero()) {
        return;
    }
    negatePolynomial_AA(poly);
}

/** 
 * Get a copy of this polynomial. 
 */ 
SparseMultivariateRationalPolynomial SparseMultivariateRationalPolynomial::deepCopy() const {
    if (isZero()) {
        return SparseMultivariateRationalPolynomial(NULL, nvar, names);
    }

    AltArr_t* copy = deepCopyPolynomial_AA(poly);
    return SparseMultivariateRationalPolynomial(copy, nvar, names);
}

Factors<SparseMultivariateRationalPolynomial> SparseMultivariateRationalPolynomial::factor() const {
    Factors<SparseMultivariateIntegerPolynomial> ZFacts;
    
    SparseMultivariateIntegerPolynomial f;
    RationalNumber content;
    f = this->primitivePartSMZP(content);
    ZFacts = f.factor();
    content *= RationalNumber(ZFacts.ringElement().leadingCoefficient());
    
    std::vector<SparseMultivariateRationalPolynomial> QFacts;
    std::vector<int> QExps;
    QFacts.reserve(ZFacts.size());
    QExps.reserve(ZFacts.size());
    for (int i=0; i<ZFacts.size(); ++i) {
    	QFacts.emplace_back(ZFacts[i].first);
    	QExps.push_back(ZFacts[i].second);
    }
    
    return Factors<SparseMultivariateRationalPolynomial>(QFacts,QExps,content);
}

static int checkDegs(degree_t* a, degree_t* b, int vars) {
    for (int i = 0; i < vars; ++i) {
        if ( (a[i]) != (b[i]) ) {
            return i;
        }
    }

    return -1;
}

static int firstNonZero(degree_t* d, int vars) {
    for (int i = vars-1; i >= 0; --i) {
        if (d[i]) {
            return i;
        }
    }

    return -1;
}

/**
 * SLP representation of the polynomial
 **/
void SparseMultivariateRationalPolynomial::straightLineProgram() {
    slp.clear();
    if (isZero()) {
        SLPRepresentation r; 
        r.type = 4;
        r.b = -1;
        r.a.c = new RationalNumber(0);
        slp.push_back(r);
        return; 
    }

    if (isConstant()) {
        SLPRepresentation r;
        r.type = 4;
        r.b = -1;
        r.a.c = new RationalNumber(poly->elems->coef);
        slp.push_back(r);
        return;
    }

    ///////
    // So basically what is happening in this below code is sort of like
    // Horner's method. We start with the highest ordered term and begin
    // at the center of this kind-of horner's method, expanding outwards
    // and adding coefficients of terms as needed, multiplying by variables
    // as well to achieve the proper degree for each term.
    // 
    // the variable d sort of keeps track of how many multiplications remain
    // for each variable, for every preceeding term in the SLP.
    // you can see that d[i] is decremented when we add a new multiplicative 
    // element to the slp. 
    // 
    // The stack here allows for multi "expansions" of horner's method for
    // different terms. When a term appears that has incompatible degree
    // with what is left to be multiplied in the preceeding horner's expansion
    // then we push that horner's expansion onto the stack and start another. 
    // then finally, popping from the stack, and adding two horner's expansions 
    // together. 
    //


    std::vector<AAElem_DegList_t*> polyStack;
    std::vector<int> indexStack;
    int prev = 0;
    bool isOp = 1;
    SLPRepresentation elem;

    AltArrDegList_t* listPoly = deepCopyPolynomial_AADegListFromAA(poly);

    degree_t* d = (degree_t*) malloc(sizeof(degree_t)*nvar);
    for (int i = 0; i < nvar; ++i) {
        d[i] = listPoly->elems->degs[i];
    }

    int polySize = listPoly->size;
    for (int i = 0; i < polySize; ++i) {
        degree_t* curd = listPoly->elems[i].degs;
        int k = checkDegs(d, curd, nvar);
        if (k > -1) {
            bool isStart = 0;

            // Mutiply smaller variate than the current one
            for (int j = nvar-1; j > k; --j) {
                if (d[j] > 0 && !polyStack.empty()) {
                    degree_t* prevd = polyStack[polyStack.size()-1]->degs;
                    while(checkDegs(prevd, d, nvar) == j) {
                        elem.op = 0;
                        elem.type = 3;
                        elem.a.i = indexStack[indexStack.size()-1];
                        elem.b = slp.size() - 1;
                        slp.push_back(elem);

                        polyStack.pop_back();
                        indexStack.pop_back();
                        if (!polyStack.empty()) {
                            prevd = polyStack[polyStack.size()-1]->degs;
                        } else {
                            break;
                        }
                    }
                }

                while (d[j] > 0) {
                    elem.op = 1;
                    elem.type = 2;
                    elem.a.i = j;
                    // elem.a = j;
                    elem.b = slp.size() - 1;
                    slp.push_back(elem);
                    d[j]--;
                }
                if (curd[j]) {
                    isStart = 1;
                    d[j] = curd[j];
                }
            }

            // Add previous result if bigger variate doesn't end
            if (!polyStack.empty()) {
                degree_t* prevd = polyStack[polyStack.size()-1]->degs;
                while(checkDegs(prevd, curd, nvar) == k) {
                    elem.op = 0;
                    elem.type = 3;
                    elem.a.i = indexStack[indexStack.size()-1];
                    elem.b = slp.size() - 1;
                    slp.push_back(elem);

                    polyStack.pop_back();
                    indexStack.pop_back();
                    if (!polyStack.empty()) {
                        prevd = polyStack[polyStack.size()-1]->degs;
                    } else {
                        break;
                    }
                }
            }

            if (d[k] < curd[k]) {
                isStart = 1;
                d[k] = curd[k];

            }
            // Mutiply this variate until current degree
            while (d[k] > curd[k]) {
                elem.op = 1;
                elem.type = 2;
                elem.a.i = k;
                elem.b = slp.size() - 1;
                slp.push_back(elem);
                d[k]--;

            }

            // Needed to add this result in future
            if (isStart) {
                isOp = 1;
                polyStack.push_back(&(listPoly->elems[prev]));
                indexStack.push_back(slp.size()-1);
            }
        }

        // Multiply or add this coefficient
        k = firstNonZero(d, nvar);
        if (isOp) {
            elem.op = 1;
            elem.type = 0;
            elem.a.c = new RationalNumber(listPoly->elems[i].coef);
            // elem.a  = i;
            elem.b = k;
            slp.push_back(elem);

            d[k]--;
        }
        else {
            elem.op = 0;
            elem.type = 1;
            elem.a.c = new RationalNumber(listPoly->elems[i].coef);
            // elem.a = i;
            elem.b = slp.size() - 1;
            slp.push_back(elem);
        }
        isOp = 0;

        prev = i;
    }

    int k = firstNonZero(d, nvar);
    if (k > -1) {
        if (!polyStack.empty()) {
            degree_t* prevd = polyStack[polyStack.size()-1]->degs;
            while (checkDegs(prevd, d, nvar) == k) {
                elem.op = 0;
                elem.type = 3;
                elem.a.i = indexStack[indexStack.size()-1];
                elem.b = slp.size() - 1;
                slp.push_back(elem);

                polyStack.pop_back();
                indexStack.pop_back();
                if (!polyStack.empty()) {
                    prevd = polyStack[polyStack.size()-1]->degs;
                } else {
                    break;
                }
            }
        }

        for (int i = k; i >= 0; --i) {
            if (polyStack.size() > 0) {
                degree_t* prevd = polyStack[polyStack.size()-1]->degs;
                while(checkDegs(prevd, d, nvar) == i) {
                    elem.op = 0;
                    elem.type = 3;
                    elem.a.i = indexStack[indexStack.size()-1];
                    elem.b = slp.size() - 1;
                    slp.push_back(elem);

                    polyStack.pop_back();
                    indexStack.pop_back();
                    if (!polyStack.empty()) {
                        prevd = polyStack[polyStack.size()-1]->degs;
                    } else {
                        break;
                    }
                }
            }

            while (d[i] > 0) {
                elem.op = 1;
                elem.type = 2;
                elem.a.i = i;
                elem.b = slp.size() - 1;
                slp.push_back(elem);
                d[i]--;
            }
        }
    }
    free(d);
    freePolynomial_AADL(listPoly);

    // Add the rest results
    if (!indexStack.empty()) {
        for (int i = indexStack.size()-1; i >= 0; --i) {
            elem.op = 0;
            elem.type = 3;
            elem.a.i = indexStack[i];
            elem.b = slp.size() - 1;
            slp.push_back(elem);
        }
    }
}

void SparseMultivariateRationalPolynomial::printSLP(std::ostream& out) const {
    int m = slp.size();
    if (m == 0) {
        out << "BPAS: No form for straight-line program." << std::endl;
        return; 
    }

    if (isConstant()) {
        //special form of SLP;
        out << "r_0:\t" << *(slp[0].a.c) << std::endl;
        return;
    }

    std::string opStr;
    for (int i = 0; i < m; ++i) {
        if (slp[i].op == 0) {
            opStr = " + ";
        } else {
            opStr = " * ";
        }

        switch (slp[i].type) {
            //coef & variate
            case 0: {
                out << "r_" << i << ":=\t" << *(slp[i].a.c) << opStr << names[slp[i].b + 1] << ":" << std::endl;
                break;
            }
            //coef & result
            case 1: {
                out << "r_" << i << ":=\t" << *(slp[i].a.c);
                if (slp[i].b >= 0) {
                    out << opStr << "r_" << slp[i].b;
                }
                out << ":" <<  std::endl;
                break;
            }
            //variate & result
            case 2: {
                out << "r_" << i << ":=\t" << names[slp[i].a.i + 1];
                if (slp[i].b >= 0) {
                    out << opStr << "r_" << slp[i].b;
                }
                out << ":" <<  std::endl;
                break;
            }
            //result & result
            case 3: {
                out << "r_" << i << ":=\tr_" << slp[i].a.i << opStr << "r_" << slp[i].b << ":" <<  std::endl;
                break;
            }
            //coef (constant);
            case 4: {
                out << "r_" << i << ":=\t" << *(slp[i].a.c) << ":" <<  std::endl;
            }
        }
    }
}

void SparseMultivariateRationalPolynomial::sleeveBoundURPolynomials(DenseUnivariateRationalPolynomial* up, DenseUnivariateRationalPolynomial* lo, Intervals& pIs, int k, int s) {
    int m = slp.size();
    if (m == 0 || isConstant()) {
        up->setCoefficient(0,0);
        lo->setCoefficient(0,0);
        return;
    }

    int d = 0;
    if (poly != NULL) {
        unsigned long long int mask = getMVarExpMask(nvar);
        int size = getMVarExpOffset(nvar);
        d = GET_NTH_EXP(poly->elems->degs, mask, size);
    }
    for (int i = 0; i < m; i++) {
        Interval a;
        if (slp[i].type == 0) {
            a.left = (*slp[i].a.c).get_mpq();
            a.right = (*slp[i].a.c).get_mpq();

            // If it is the last variate,
            // set the coefficient of bound polynomials.
            if (slp[i].b > 0) {
                if (slp[i].op)
                    intervalMultiplication(&(slp[i].res), &a, pIs.interval(k, slp[i].b));
                else
                    intervalAddition(&(slp[i].res), &a, pIs.interval(k, slp[i].b));
            }
            else {
                if (s && d%2) {
                    up->setCoefficient(d, RationalNumber(-a.left));
                    lo->setCoefficient(d, RationalNumber(-a.right));
                }
                else {
                    up->setCoefficient(d, RationalNumber(a.right));
                    lo->setCoefficient(d, RationalNumber(a.left));
                }
                d--;
                slp[i].res.left = 0;
                slp[i].res.right = 0;
            }
        }
        else if (slp[i].type == 1) {
            a.left = (*slp[i].a.c).get_mpq();
            a.right = (*slp[i].a.c).get_mpq();
            if (slp[i].op)
                intervalMultiplication(&(slp[i].res), &a, &(slp[slp[i].b].res));
            else
                intervalAddition(&(slp[i].res), &a, &(slp[slp[i].b].res));
        }
        else if (slp[i].type == 2) {
            // If it is the last variate,
            // set the coefficient of bound polynomials.
            if (slp[i].a.i > 0) {
                if (slp[i].op)
                    intervalMultiplication(&(slp[i].res), &(slp[slp[i].b].res), pIs.interval(k, slp[i].a.i));
                else
                    intervalAddition(&(slp[i].res), &(slp[slp[i].b].res), pIs.interval(k, slp[i].a.i));
            }
            else {
                if (s && d%2) {
                    up->setCoefficient(d, RationalNumber(-slp[slp[i].b].res.left));
                    lo->setCoefficient(d, RationalNumber(-slp[slp[i].b].res.right));
                }
                else {
                    up->setCoefficient(d, RationalNumber(slp[slp[i].b].res.right));
                    lo->setCoefficient(d, RationalNumber(slp[slp[i].b].res.left));
                }
                d--;
                slp[i].res.left = 0;
                slp[i].res.right = 0;
            }
        }
        else {      // slp[i].type == 3
            if (slp[i].op)
                intervalMultiplication(&(slp[i].res), &(slp[slp[i].a.i].res), &(slp[slp[i].b].res));
            else
                intervalAddition(&(slp[i].res), &(slp[slp[i].a.i].res), &(slp[slp[i].b].res));
        }
    }

    up->setCoefficient(0, slp[m-1].res.right);
    lo->setCoefficient(0, slp[m-1].res.left);
}

void SparseMultivariateRationalPolynomial::randomPolynomial(int numvar, int nterms, unsigned long int coefBound, degree_t sparsity, bool includeNeg) {

    *this = SparseMultivariateRationalPolynomial(numvar);

    if (numvar == 0) {
        poly = makePolynomial_AA(1, nvar);
        mpq_init(poly->elems->coef);
        mpq_set_si(poly->elems->coef, (rand() % ((int) pow(2, coefBound-1))) + 1, 1);
        poly->elems->degs = 0;
        poly->size = 1;

    } else {
        Node* node = buildRandomPoly(numvar, nterms, coefBound, sparsity, includeNeg);
        poly = deepCopyPolynomial_AAFromNode(node, nvar);
        freePolynomial(node);
    }
}

void SparseMultivariateRationalPolynomial::randomPolynomial(std::vector<int> maxDegs, unsigned long int coefBound, float sparsity, bool includeNeg) {

    AltArr_t* aa = buildRandomPolyFromMax(maxDegs.size(), maxDegs.data(), coefBound, sparsity, includeNeg);

    *this = SparseMultivariateRationalPolynomial(maxDegs.size());
    this->poly = aa;
}



/**
 * Construct an ExprTreeNode (well, multiple) which represents a single
 * term. That is, a coefficient and a monomial.
 */
ExprTreeNode* exprTreeNodeFromAAElem(const AAElem_t* n, int nvar, const Symbol* vars, int* sizes, unsigned long long int* masks) {
    if (n == NULL) {
        return new ExprTreeNode(0l);
    }

    degrees_t degs = n->degs;
    ExprTreeNode* t = new ExprTreeNode(mpq_class(n->coef));
    
    for (int i = 0; i < nvar; ++i) {
        degree_t deg = GET_NTH_EXP(degs, masks[i], sizes[i]); 

        if (deg > 1) {
            ExprTreeNode* var = new ExprTreeNode(vars[i]);
            ExprTreeNode* num = new ExprTreeNode(deg);
            ExprTreeNode* exp = ExprTreeNode::combineExprTreeNodes(var, num, EXPR_EXP);
            t = ExprTreeNode::combineExprTreeNodes(t, exp, EXPR_MULT);
        } else if (deg == 1) {
            ExprTreeNode* var = new ExprTreeNode(vars[i]);
            t = ExprTreeNode::combineExprTreeNodes(t, var, EXPR_MULT);
        }
    }

    return t;
}

ExpressionTree SparseMultivariateRationalPolynomial::convertToExpressionTree() const {
    if (isZero()) {
        ExprTreeNode* r = new ExprTreeNode(0l);
        ExpressionTree t(r);
        return t; 
    }

    int* sizes = NULL;
    unsigned long long int* masks = NULL;
    if (nvar > 0) {
        masks = getExpMaskArray(nvar);
        sizes = getExpOffsetArray(nvar);
    } 
   
    ExprTreeNode* prev = exprTreeNodeFromAAElem(poly->elems, nvar, &names[1], sizes, masks);
    for (int i = 1; i < poly->size; ++i) {
        ExprTreeNode* thisNode = exprTreeNodeFromAAElem(&(poly->elems[i]), nvar, &names[1], sizes, masks);
        prev = ExprTreeNode::combineExprTreeNodes(prev, thisNode, EXPR_ADD);
    }

    free(sizes);
    free(masks);

    return ExpressionTree(prev);
}
